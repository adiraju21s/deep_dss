import numpy as np
import healpy as hp
import pandas as pd
from numba import jit
from sklearn.utils import shuffle

from deepsphere import experiment_helper
from deepsphere.data import LabeledDataset


# Constants


def set_constants():
    """
    Sets constants for future functions (especially accelerated ones)
    :return: NSIDE, NPIX, PIXEL_AREA (in arcmin^2), ORDER, BIAS, DENSITY_M, DENSITY_KG and ELLIP_SIGMA
    """
    nside = 1024
    npix = hp.nside2npix(nside)
    pixel_area = hp.nside2pixarea(nside, degrees=True) * 3600
    order = 2
    bias = 1.54
    density_m = 0.04377
    density_kg = 10
    ellip_sigma = 0.25
    return nside, npix, pixel_area, order, bias, density_m, density_kg, ellip_sigma


(NSIDE, NPIX, PIXEL_AREA, ORDER, BIAS, DENSITY_M, DENSITY_KG, ELLIP_SIGMA) = set_constants()

MACHINE = "LOCAL"


# MACHINE = "BRIDGES"


def set_paths(machine):
    """
    Sets directory paths based on the machine being used
    :return: PATH_TO_INPUT, PATH_TO_OUTPUT, PATH_TO_CHECKPOINTS and PATH_TO_VAL
    """
    path_to_input = ""
    path_to_output = ""
    path_to_checkpoints = ""
    path_to_val = ""
    if machine == "LOCAL":
        path_to_input = "../data/flask101/input/"
        path_to_output = "../data/flask101/output/"
        path_to_checkpoints = ""
        path_to_val = "../validation_101.npz"
    elif machine == "BRIDGES":
        path_to_input = "/pylon5/ch4s8kp/adiraj21/flaskwrapper/input/"
        path_to_output = "/pylon5/ch4s8kp/adiraj21/flaskwrapper/output/"
        path_to_checkpoints = ""
        path_to_val = "/pylon5/ch4s8kp/adiraj21/DeepSphere/validation_101.npz"
    else:
        print("Invalid machine configuration for set_paths(). Please try again.")
    return path_to_input, path_to_output, path_to_checkpoints, path_to_val


(PATH_TO_INPUT, PATH_TO_OUTPUT, PATH_TO_CHECKPOINTS, PATH_TO_VAL) = set_paths(MACHINE)


# C(l) helper functions

def path_to_cl(sigma8, name="f1z1f1z1", path_to_input=PATH_TO_INPUT):
    """
    Returns relative path to FLASK input C(l) generated by trough_lenser
    :param sigma8:Value of $\\sigma_8$ used to generate the C(l)s
    :param name: Name of the C(l)
    :param path_to_input: Path to flask101 input directory, ending in / (default assumes data folder in repo)
    :return: relative path string to the appropriate C(l) file
    """
    return path_to_input + "dss-20-0.28-{0}-1.54/dss-20-0.28-{0}-1.54Cl-{1}.dat".format(round(sigma8, 3), name)


def load_cl_from_path(path, lmax=10000):
    """
    Generate pandas dataframe for a given input C(l) file
    :param path: path to C(l) file
    :param lmax: maximum l value in C(l) file
    :return: data frame containing vector of ls and corresponding C(l) values
    """
    data = pd.read_csv(path, sep=' ', header=None)
    data.columns = ['L', 'CL']
    data.index = np.arange(lmax + 1)
    return data


def load_cl_from_val(sigma8, lmax=10000, name="f1z1f1z1", path_to_input=PATH_TO_INPUT):
    """
    Wrapper function to return pandas data frame for a specified C(l)
    :param sigma8: Value of $\\sigma_8$ used to generate the C(l)s
    :param lmax: maximum l value in C(l) file
    :param name: Name of the C(l)
    :param path_to_input: Path to flask101 input directory, ending in / (default assumes data folder in repo)
    :return: data frame containing vector of ls and corresponding C(l) values
    """
    return load_cl_from_path(path_to_cl(sigma8, name=name, path_to_input=path_to_input), lmax=lmax)


# Descriptions of different data sets

def full_cosmologies_list():
    """
    Return the full list of $\\sigma_8$ values in the simulated data
    :return: A numpy array covering all 101 $\\sigma_8$ values in the flat prior
    """
    return np.linspace(0.5, 1.2, num=101)


def q1_cosmologies_list():
    """
    Return the list of $\\sigma_8$ values used in training Q1
    :return: A numpy array of 20 $\\sigma_8$ values
    """
    return np.array([1.165, 0.766, 1.095, 0.976, 0.99, 0.773, 0.57, 0.64, 0.563,
                     1.193, 0.584, 0.542, 1.109, 0.969, 0.983, 0.675, 1.039, 0.927,
                     1.032, 1.06])


def q2_cosmologies_list():
    """
    Return the list of $\\sigma_8$ values used in training Q2
    :return: A numpy array of 20 $\\sigma_8$ values
    """
    return np.array([0.843, 0.857, 0.535, 1.186, 1.144, 0.906, 0.962, 1.067, 0.815,
                     0.822, 0.717, 0.808, 1.13, 1.004, 0.626, 1.123, 0.724, 0.913,
                     0.696, 0.745])


def q3_cosmologies_list():
    """
    Return the list of $\\sigma_8$ values used in training Q3
    :return: A numpy array of 20 $\\sigma_8$ values
    """
    return np.array([0.829, 0.605, 0.647, 1.088, 0.864, 0.92, 0.661, 0.997, 0.955,
                     1.053, 0.759, 0.703, 0.934, 0.738, 0.752, 1.018, 0.794, 0.619,
                     0.892, 1.116])


def q4_cosmologies_list():
    """
    Return the list of $\\sigma_8$ values used in training Q4
    :return: A numpy array of 20 $\\sigma_8$ values
    """
    return np.array([0.787, 0.5, 0.836, 0.577, 1.179, 0.899, 0.598, 0.78, 0.941,
                     0.528, 1.2, 1.081, 0.948, 0.507, 0.633, 0.85, 1.137, 0.689,
                     1.074, 0.521])


def test_cosmologies_list():
    """
    Return the list of $\\sigma_8$ values used in testing
    :return: A numpy array of 21 $\\sigma_8$ values
    """
    return np.array([0.682, 1.102, 0.514, 0.885, 1.025, 1.158, 0.612, 1.011, 0.878,
                     1.172, 0.871, 1.151, 1.046, 0.591, 0.549, 0.71, 0.654, 0.668,
                     0.731, 0.556, 0.801])


def cosmologies_list(dataset):
    """
    Returns list of $\\sigma_8$ values for an input data set
    :param dataset: Name of data set
    :return: Numpy array of 20, 21, or 101 values
    """
    if dataset == "Q1":
        return q1_cosmologies_list()
    if dataset == "Q2":
        return q2_cosmologies_list()
    if dataset == "Q3":
        return q3_cosmologies_list()
    if dataset == "Q4":
        return q4_cosmologies_list()
    if dataset == "TEST":
        return test_cosmologies_list()
    if dataset == "FULL":
        return full_cosmologies_list()
    print("Invalid data set specification. Please try again")


def dataset_names(val=False):
    """
    Returns list of data set names
    :param val: Whether or not to include the validation set
    :return: List of strings
    """
    if val:
        return ["Q1", "Q2", "Q3", "Q4", "TEST", "VAL"]
    return ["Q1", "Q2", "Q3", "Q4", "TEST"]


# Map loading functions

def path_to_map(sigma8, name="map-f1z1.fits.gz", path_to_output=PATH_TO_OUTPUT):
    """
    Return relative path to Healpix map given $\\sigma_8$
    :param sigma8: Value of $\\sigma_8$$ from which the map was generated
    :param name: Name of the map file
    :param path_to_output: Relative path to the FLASK output directory
    :return: String with path
    """
    return path_to_output + "dss-20-0.28-{0}-1.54/{1}".format(round(sigma8, 3), name)


def load_map_by_path(path, field=0, nest=True):
    """
    Returns HEALPIX map located at a given path
    :param path: relative path to the map
    :param field: field of the map (for lensing maps with multiple fields)
    :param nest: True for NEST pixellization, False for RING
    :return: Numpy array with map
    """
    return hp.read_map(path, field=field, nest=nest)


def load_map_by_val(sigma8, name="map-f1z1.fits.gz", path_to_output=PATH_TO_OUTPUT, field=0, nest=True):
    """
    Returns HEALPIX map for FLASK realization of a given $\\sigma_8$ value
    :param sigma8: Value of $\\sigma_8$
    :param name: name of the map
    :param path_to_output: relative path to the FLASK output directory
    :param field: field of the map (for lensing maps with multiple fields)
    :param nest: True for NEST pixelization, False for RING
    :return: Numpy array with map
    """
    return load_map_by_path(path_to_map(sigma8, name=name, path_to_output=path_to_output), field=field, nest=nest)


def load_shear_maps_by_val(sigma8, coadd=True, corr=None, path_to_output=PATH_TO_OUTPUT, nest=True):
    """
    Returns list of two HEALPIX maps (for $\\gamma_1$ and $\\gamma_2$) for FLASK realization of a
    given $\\sigma_8$ value
    :param sigma8: Value of $\\sigma_8$
    :param coadd: If True, coadds correlated and uncorrelated signals
    :param corr: If coadd is False, determines whether correlated or uncorrelated signals are returned
    :param path_to_output: relative path to the FLASK output directory
    :param nest: True for NEST pixelization, False for RING
    :return: List of two Numpy arrays
    """
    if coadd:
        return [load_map_by_val(sigma8, name="kappa-gamma-f2z1.fits.gz", path_to_output=path_to_output, field=i + 1,
                                nest=nest) + load_map_by_val(sigma8, name="kappa-gamma-f2z2.fits.gz",
                                                             path_to_output=path_to_output, field=i + 1, nest=nest) for
                i in
                range(2)]
    if corr:
        return [load_map_by_val(sigma8, name="kappa-gamma-f2z1.fits.gz", path_to_output=path_to_output, field=i + 1,
                                nest=nest) for i in range(2)]
    return [load_map_by_val(sigma8, name="kappa-gamma-f2z2.fits.gz", path_to_output=path_to_output, field=i + 1,
                            nest=nest) for i in range(2)]


def load_convergence_map_by_val(sigma8, coadd=True, corr=None, path_to_output=PATH_TO_OUTPUT, nest=True):
    """
    Returns HEALPIX map (for $\\kappa$) for FLASK realization of a given $\\sigma_8$ value
    :param sigma8: Value of $\\sigma_8$
    :param coadd: If True, coadds correlated and uncorrelated signals
    :param corr: If coadd is False, determines whether correlated or uncorrelated signals are returned
    :param path_to_output: relative path to the FLASK output directory
    :param nest: True for NEST pixelization, False for RING
    :return: Numpy array storing HEALPIX map
    """
    if coadd:
        return load_map_by_val(sigma8, name="kappa-gamma-f2z1.fits.gz", path_to_output=path_to_output, field=0,
                               nest=nest) + load_map_by_val(sigma8, name="kappa-gamma-f2z2.fits.gz",
                                                            path_to_output=path_to_output, field=0, nest=nest)
    if corr:
        return load_map_by_val(sigma8, name="kappa-gamma-f2z1.fits.gz", path_to_output=path_to_output, field=0,
                               nest=nest)
    return load_map_by_val(sigma8, name="kappa-gamma-f2z2.fits.gz", path_to_output=path_to_output, field=0,
                           nest=nest)


@jit(nopython=True)
def accelerated_noiseless_counts(m, npix=NPIX, pixarea=PIXEL_AREA,
                                 density=DENSITY_M, density_0=DENSITY_M, multiplier=1.0, bias=BIAS,
                                 normalize=True):
    """
    Returns new version of input map without any Poissonian shot noise applied.
    :param m: FLASK output map of galaxy density contrast, $\\delta_g$
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param density: Tracer galaxy density, in arcmin^2, to use for noise application
    :param density_0: Baseline galaxy density, in arcmin^2, to scale distribution by
    :param multiplier: Scale factor used to amplify noise distribution
    :param bias: Linear galaxy-matter bias
    :param normalize: True if resulting noise should be made to reflect a linear galaxy-matter bias of 1
    :return: A noiseless output map
    """
    x = np.zeros(m.shape)
    for i in range(npix):
        if normalize:
            x[i] = multiplier * (density_0 / density) * (density * pixarea * (1 + m[i] / bias))
        else:
            x[i] = multiplier * (density_0 / density) * (density * pixarea * (1 + m[i]))
    return x


@jit(nopython=True)
def accelerated_noiseless_shear(g, npix=NPIX, multiplier=1.0):
    """
    Returns new version of input maps without any Gaussian shape noise applied.
    :param g: FLASK output maps of lensing shear, $\\gamma_1$ and $\\gamma_2$
    :param npix: Number of pixels in map
    :param multiplier: Scale factor used to amplify noise distribution
    :return: A noiseless list of output maps
    """
    x = [np.zeros(g[i].shape) for i in range(2)]
    for c in range(2):
        for i in range(npix):
            x[c][i] = multiplier * g[c][i]
    return x


@jit(nopython=True)
def accelerated_noiseless_convergence(k, npix=NPIX, multiplier=1.0):
    """
    Returns new version of input map without any Gaussian shape noise applied.
    :param k: FLASK output maps of lensing convergence, $\\kappa$
    :param npix: Number of pixels in map
    :param multiplier: Scale factor used to amplify noise distribution
    :return: A noiseless output map
    """
    x = np.zeros(k.shape)
    for i in range(npix):
        x[i] = multiplier * k[i]
    return x


@jit(nopython=True)
def accelerated_poissonian_shot_noise(m, npix=NPIX, pixarea=PIXEL_AREA,
                                      density=DENSITY_M, density_0=DENSITY_M, multiplier=1.0, bias=BIAS,
                                      normalize=True):
    """
    Returns new version of input map with a specified level of Poissonian shot noise applied.
    :param m: FLASK output map of galaxy density contrast, $\\delta_g$
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param density: Tracer galaxy density, in arcmin^2, to use for noise application
    :param density_0: Baseline galaxy density, in arcmin^2, to scale distribution by
    :param multiplier: Scale factor used to amplify noise distribution
    :param bias: Linear galaxy-matter bias
    :param normalize: True if resulting noise should be made to reflect a linear galaxy-matter bias of 1
    :return: A noisy Poisson-sampled output map
    """
    x = np.zeros(m.shape)
    for i in range(npix):
        if normalize:
            x[i] = multiplier * (density_0 / density) * np.random.poisson(density * pixarea * (1 + m[i] / bias))
        else:
            x[i] = multiplier * (density_0 / density) * np.random.poisson(density * pixarea * (1 + m[i]))
    return x


@jit(nopython=True)
def accelerated_gaussian_shear_noise(g, npix=NPIX, pixarea=PIXEL_AREA,
                                     density=DENSITY_KG, density_0=DENSITY_KG, multiplier=1.0,
                                     ellip_sigma=ELLIP_SIGMA):
    """
    Returns new version of input map with a specified level of Gaussian shape noise applied.
    :param ellip_sigma: Standard deviation representing uncertainty in ellipticity measurements
    :param g: FLASK output maps of lensing shear ($\\gamma_1$ and $\\gamma_2$)
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param density: Source galaxy density, in arcmin^2, to use for noise application
    :param density_0: Baseline galaxy density, in arcmin^2, to scale distribution by
    :param multiplier: Scale factor used to amplify noise distribution
    :return: A list of two noisy Gaussian-sampled output maps
    """
    x = [np.zeros(g[i].shape) for i in range(2)]
    for c in range(2):
        for i in range(npix):
            x[c][i] = multiplier * (density_0 / density) * np.random.normal(loc=g[c][i], scale=ellip_sigma / np.sqrt(
                pixarea * density))
    return x


@jit(nopython=True)
def accelerated_gaussian_convergence_noise(k, npix=NPIX, pixarea=PIXEL_AREA,
                                           density=DENSITY_KG, density_0=DENSITY_KG, multiplier=1.0,
                                           ellip_sigma=ELLIP_SIGMA):
    """
    Returns new version of input map with a specified level of Gaussian shape noise applied.
    (Modeled after https://arxiv.org/pdf/2007.06529.pdf)
    :param k: FLASK output maps of lensing convergence ($\\kappa$)
    :param ellip_sigma: Standard deviation representing uncertainty in ellipticity measurements
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param density: Source galaxy density, in arcmin^2, to use for noise application
    :param density_0: Baseline galaxy density, in arcmin^2, to scale distribution by
    :param multiplier: Scale factor used to amplify noise distribution
    :return: A noisy Gaussian-sampled output map
    """
    x = np.zeros(k.shape)
    for i in range(npix):
        x[i] = multiplier * (density_0 / density) * np.random.normal(loc=k[i], scale=ellip_sigma / np.sqrt(
            2 * pixarea * density))
    return x


def count_map_by_val(sigma8, name="map-f1z1.fits.gz", path_to_output=PATH_TO_OUTPUT, field=0, nest=True,
                     npix=NPIX, pixarea=PIXEL_AREA, density=DENSITY_M, density_0=DENSITY_M, multiplier=1.0,
                     bias=BIAS, normalize=True, noiseless=False):
    """
    Loads galaxy density contrast map for a given $\\sigma_8$ and applies Poissonian shot noise
    :param sigma8: Value of $\\sigma_8$
    :param name: name of the map
    :param path_to_output: relative path to the FLASK output directory
    :param field: field of the map (for lensing maps with multiple fields)
    :param nest: True for NEST pixellization, False for RING
    :return: Numpy array with map
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param nest: True if "NEST" pixelization, False if "RING"
    :param density: Tracer galaxy density, in arcmin^2, to use for noise application
    :param density_0: Baseline galaxy density, in arcmin^2, to scale distribution by
    :param multiplier: Scale factor used to amplify noise distribution
    :param bias: Linear galaxy-matter bias
    :param normalize: True if resulting noise should be made to reflect a linear galaxy-matter bias of 1
    :param noiseless: Does not take Poisson draw if True
    :return: A noisy Poisson-sampled output map
    """
    if noiseless:
        return accelerated_noiseless_counts(
            load_map_by_val(sigma8, name=name, path_to_output=path_to_output, field=field, nest=nest),
            npix=npix, pixarea=pixarea, density=density, density_0=density_0, multiplier=multiplier, bias=bias,
            normalize=normalize)
    return accelerated_poissonian_shot_noise(
        load_map_by_val(sigma8, name=name, path_to_output=path_to_output, field=field, nest=nest),
        npix=npix, pixarea=pixarea, density=density, density_0=density_0, multiplier=multiplier, bias=bias,
        normalize=normalize)


def shear_maps_by_val(sigma8, coadd=True, corr=None, path_to_output=PATH_TO_OUTPUT, nest=True, npix=NPIX,
                      pixarea=PIXEL_AREA,
                      density=DENSITY_KG, density_0=DENSITY_KG, multiplier=1.0,
                      ellip_sigma=ELLIP_SIGMA, noiseless=False):
    """
    Loads lensing shear maps for a given $\\sigma_8$ and applies Gaussian shape noise
    :param noiseless: Does not take Gaussian draw if True
    :param sigma8: Value of $\\sigma_8$
    :param coadd: If True, coadds correlated and uncorrelated signals
    :param corr: If coadd is False, determines whether correlated or uncorrelated signals are returned
    :param path_to_output: relative path to the FLASK output directory
    :param nest: True for NEST pixelization, False for RING
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param density: Source galaxy density, in arcmin^2, to use for noise application
    :param density_0: Baseline galaxy density, in arcmin^2, to scale distribution by
    :param multiplier: Scale factor used to amplify noise distribution
    :param ellip_sigma: Standard deviation representing uncertainty in ellipticity measurements
    :return: A list of two noisy Gaussian-sampled output maps
    """
    if noiseless:
        return accelerated_noiseless_shear(
            load_shear_maps_by_val(sigma8, coadd=coadd, corr=corr, path_to_output=path_to_output, nest=nest), npix=npix,
            multiplier=multiplier)
    return accelerated_gaussian_shear_noise(
        load_shear_maps_by_val(sigma8, coadd=coadd, corr=corr, path_to_output=path_to_output, nest=nest), npix=npix,
        pixarea=pixarea, density=density, density_0=density_0, multiplier=multiplier, ellip_sigma=ellip_sigma)


def convergence_map_by_val(sigma8, coadd=True, corr=None, path_to_output=PATH_TO_OUTPUT, nest=True, npix=NPIX,
                           pixarea=PIXEL_AREA,
                           density=DENSITY_KG, density_0=DENSITY_KG, multiplier=1.0,
                           ellip_sigma=ELLIP_SIGMA, noiseless=False):
    """
    Loads lensing convergence map for a given $\\sigma_8$ and applies Gaussian shape noise
    :param noiseless: Does not take Gaussian draw if True
    :param sigma8: Value of $\\sigma_8$
    :param coadd: If True, coadds correlated and uncorrelated signals
    :param corr: If coadd is False, determines whether correlated or uncorrelated signals are returned
    :param path_to_output: relative path to the FLASK output directory
    :param nest: True for NEST pixelization, False for RING
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param density: Source galaxy density, in arcmin^2, to use for noise application
    :param density_0: Baseline galaxy density, in arcmin^2, to scale distribution by
    :param multiplier: Scale factor used to amplify noise distribution
    :param ellip_sigma: Standard deviation representing uncertainty in ellipticity measurements
    :return: A noisy Gaussian-sampled output map
    """
    if noiseless:
        return accelerated_noiseless_convergence(
            load_convergence_map_by_val(sigma8, coadd=coadd, corr=corr, path_to_output=path_to_output, nest=nest),
            npix=npix,
            multiplier=multiplier)
    return accelerated_gaussian_convergence_noise(
        load_convergence_map_by_val(sigma8, coadd=coadd, corr=corr, path_to_output=path_to_output, nest=nest),
        npix=npix,
        pixarea=pixarea, density=density, density_0=density_0, multiplier=multiplier, ellip_sigma=ellip_sigma)


def split_map(m, order=ORDER, nest=True):
    """
    Returns Numpy array of partial-sky Healpix realizations split from an input full-sky map
    :param m: Full-sky Healpix map
    :param order: ORDER giving the number of maps to split into (12*ORDER**2)
    :param nest: True if "NEST" pixelization, False if "RING"
    :return: Numpy array of split maps
    """
    return experiment_helper.hp_split(m, order, nest=nest)


def split_count_maps_by_val(sigma8, name="map-f1z1.fits.gz", path_to_output=PATH_TO_OUTPUT, field=0,
                            nest=True, npix=NPIX, pixarea=PIXEL_AREA, density=DENSITY_M, density_0=DENSITY_M,
                            multiplier=1.0,
                            bias=BIAS, normalize=True, order=ORDER, noiseless=False):
    """
    Generates partial-sky maps with applied Poissonian shot noise for a given $\\sigma_8$
    :param sigma8: Value of $\\sigma_8$
    :param name: name of the map
    :param path_to_output: relative path to the FLASK output directory
    :param field: field of the map (for lensing maps with multiple fields)
    :param nest: True for NEST pixellization, False for RING
    :return: Numpy array with map
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param nest: True if "NEST" pixelization, False if "RING"
    :param density: Tracer galaxy density, in arcmin^2, to use for noise application
    :param density_0: Baseline galaxy density, in arcmin^2, to scale distribution by
    :param multiplier: Scale factor used to amplify noise distribution
    :param bias: Linear galaxy-matter bias
    :param normalize: True if resulting noise should be made to reflect a linear galaxy-matter bias of 1
    :param order: ORDER giving the number of maps to split into (12*ORDER**2)
    :param noiseless: Does not take Poisson draw if True
    :return: Numpy array of split, (rescaled) Poisson-sampled maps
    """
    return split_map(count_map_by_val(sigma8, name=name, path_to_output=path_to_output, field=field, nest=nest,
                                      npix=npix, pixarea=pixarea, density=density, density_0=density_0,
                                      multiplier=multiplier,
                                      bias=bias, normalize=normalize, noiseless=noiseless), order=order, nest=nest)


def split_shear_maps_by_val(sigma8, coadd=True, corr=None, path_to_output=PATH_TO_OUTPUT, nest=True, npix=NPIX,
                            pixarea=PIXEL_AREA,
                            density=DENSITY_KG, density_0=DENSITY_KG, multiplier=1.0,
                            ellip_sigma=ELLIP_SIGMA, noiseless=False, order=ORDER):
    """
    Generates partial-sky shear maps with applied Gaussian shape noise for a given $\\sigma_8$
    :param sigma8: Value of $\\sigma_8$
    :param coadd: If True, coadds correlated and uncorrelated signals
    :param corr: If coadd is False, determines whether correlated or uncorrelated signals are returned
    :param path_to_output: relative path to the FLASK output directory
    :param nest: True for NEST pixelization, False for RING
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param density: Source galaxy density, in arcmin^2, to use for noise application
    :param density_0: Baseline galaxy density, in arcmin^2, to scale distribution by
    :param multiplier: Scale factor used to amplify noise distribution
    :param ellip_sigma: Standard deviation representing uncertainty in ellipticity measurements
    :param noiseless: Does not take Gaussian draw if True
    :param order: ORDER giving the number of maps to split into (12*ORDER**2)
    :return: Numpy array of split, (rescaled) Gaussian-sampled maps
    """
    g = shear_maps_by_val(sigma8, coadd=coadd, corr=corr, path_to_output=path_to_output, nest=nest, npix=npix,
                          pixarea=pixarea, density=density, density_0=density_0, multiplier=multiplier,
                          ellip_sigma=ellip_sigma, noiseless=noiseless)
    return [split_map(g[i], order=order, nest=nest) for i in range(2)]


def split_convergence_maps_by_val(sigma8, coadd=True, corr=None, path_to_output=PATH_TO_OUTPUT, nest=True, npix=NPIX,
                                  pixarea=PIXEL_AREA,
                                  density=DENSITY_KG, density_0=DENSITY_KG, multiplier=1.0,
                                  ellip_sigma=ELLIP_SIGMA, noiseless=False, order=ORDER):
    """
    Generates partial-sky convergence maps with applied Gaussian shape noise for a given $\\sigma_8$
    :param sigma8: Value of $\\sigma_8$
    :param coadd: If True, coadds correlated and uncorrelated signals
    :param corr: If coadd is False, determines whether correlated or uncorrelated signals are returned
    :param path_to_output: relative path to the FLASK output directory
    :param nest: True for NEST pixelization, False for RING
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param density: Source galaxy density, in arcmin^2, to use for noise application
    :param density_0: Baseline galaxy density, in arcmin^2, to scale distribution by
    :param multiplier: Scale factor used to amplify noise distribution
    :param ellip_sigma: Standard deviation representing uncertainty in ellipticity measurements
    :param noiseless: Does not take Gaussian draw if True
    :param order: ORDER giving the number of maps to split into (12*ORDER**2)
    :return: Numpy array of split, (rescaled) Gaussian-sampled maps
    """
    return split_map(
        convergence_map_by_val(sigma8, coadd=coadd, corr=corr, path_to_output=path_to_output, nest=nest, npix=npix,
                               pixarea=pixarea, density=density, density_0=density_0, multiplier=multiplier,
                               ellip_sigma=ellip_sigma, noiseless=noiseless), order=order, nest=nest)


def split_lensing_maps_by_val(sigma8, config="g", coadd=True, corr=None, path_to_output=PATH_TO_OUTPUT, nest=True,
                              npix=NPIX,
                              pixarea=PIXEL_AREA,
                              density=DENSITY_KG, density_0=DENSITY_KG, multiplier=1.0,
                              ellip_sigma=ELLIP_SIGMA, noiseless=False, order=ORDER):
    """
    Generates a set of partial-sky lensing maps with applied Gaussian shape noise for a given $\\sigma_8$
    :param sigma8: Value of $\\sigma_8$
    :param coadd: If True, coadds correlated and uncorrelated signals
    :param corr: If coadd is False, determines whether correlated or uncorrelated signals are returned
    :param path_to_output: relative path to the FLASK output directory
    :param nest: True for NEST pixelization, False for RING
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param density: Source galaxy density, in arcmin^2, to use for noise application
    :param density_0: Baseline galaxy density, in arcmin^2, to scale distribution by
    :param multiplier: Scale factor used to amplify noise distribution
    :param ellip_sigma: Standard deviation representing uncertainty in ellipticity measurements
    :param noiseless: Does not take Gaussian draw if True
    :param order: ORDER giving the number of maps to split into (12*ORDER**2)
    :param config: "k" for convergence only, "g" for shear only, "kg" for convergence and shear
    :return: Numpy array of split, (rescaled) Gaussian-sampled maps
    """
    if config == "g":
        g = split_shear_maps_by_val(sigma8, coadd=coadd, corr=corr, path_to_output=path_to_output, nest=nest, npix=npix,
                                    pixarea=pixarea, density=density, density_0=density_0, multiplier=multiplier,
                                    ellip_sigma=ellip_sigma, noiseless=noiseless, order=order)
        return np.stack((g[0], g[1]), axis=2)
    if config == "k":
        return split_convergence_maps_by_val(sigma8, coadd=coadd, corr=corr, path_to_output=path_to_output, nest=nest,
                                             npix=npix,
                                             pixarea=pixarea, density=density, density_0=density_0,
                                             multiplier=multiplier,
                                             ellip_sigma=ellip_sigma, noiseless=noiseless, order=order)
    if config == "kg":
        g = split_shear_maps_by_val(sigma8, coadd=coadd, corr=corr, path_to_output=path_to_output, nest=nest, npix=npix,
                                    pixarea=pixarea, density=density, density_0=density_0, multiplier=multiplier,
                                    ellip_sigma=ellip_sigma, noiseless=noiseless, order=order)
        k = split_convergence_maps_by_val(sigma8, coadd=coadd, corr=corr, path_to_output=path_to_output, nest=nest,
                                          npix=npix,
                                          pixarea=pixarea, density=density, density_0=density_0, multiplier=multiplier,
                                          ellip_sigma=ellip_sigma, noiseless=noiseless, order=order)
        return np.stack((g[0], g[1], k), axis=2)
    print("Unknown config in deep_dss.utils.split_lensing_maps_by_val. Please try again.")


def split_count_maps_by_vals(sigma8s, name="map-f1z1.fits.gz", path_to_output=PATH_TO_OUTPUT, field=0,
                             nest=True, npix=NPIX, pixarea=PIXEL_AREA, density=DENSITY_M, density_0=DENSITY_M,
                             multiplier=1.0,
                             bias=BIAS, normalize=True, noiseless=False, order=ORDER, scramble=False,
                             ground_truths=True, reshape_x=False, reshape_y=True, deepsphere_dataset=False):
    """
    Generates stacked array of partial-sky Poisson-sampled maps for a list of $\\sigma_8$ values
    :param deepsphere_dataset: Returns a DeepSphere LabeledDataset if true
    :param reshape_y: If True, reshapes ys to have shape (.., .., 1)
    :param reshape_x: If True, reshapes xs to have shape (.., .., 1)
    :param sigma8s: List of $\\sigma_8$ values
    :param name: name of the map
    :param path_to_output: relative path to the FLASK output directory
    :param field: field of the map (for lensing maps with multiple fields)
    :param nest: True for NEST pixellization, False for RING
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param nest: True if "NEST" pixelization, False if "RING"
    :param density: Tracer galaxy density, in arcmin^2, to use for noise application
    :param density_0: Baseline galaxy density, in arcmin^2, to scale distribution by
    :param multiplier: Scale factor used to amplify noise distribution
    :param bias: Linear galaxy-matter bias
    :param normalize: True if resulting noise should be made to reflect a linear galaxy-matter bias of 1
    :param noiseless: Does not take Poisson draw if True
    :param order: ORDER giving the number of maps to split into (12*ORDER**2)
    :param scramble: If True, randomly scrambles the maps out of order
    :param ground_truths: True if corresponding labels should be returned as well
    :return: Dictionary of DeepSphere datasets if deepsphere_dataset=True, maps and labels if ground_truths=True,
        stacked Numpy array of split, (rescaled) Poisson-sampled maps otherwise
    """
    x = np.empty((0, npix // (12 * order * order)))
    for sigma8 in sigma8s:
        m = split_count_maps_by_val(sigma8, name=name, path_to_output=path_to_output, field=field,
                                    nest=nest, npix=npix, pixarea=pixarea, density=density, density_0=density_0,
                                    multiplier=multiplier,
                                    bias=bias, normalize=normalize, noiseless=noiseless, order=order)
        x = np.vstack((x, m))
    if reshape_x:
        x = np.reshape(x, (len(sigma8s) * 12 * order * order, npix // (12 * order * order), 1))
    if ground_truths:
        y = np.zeros(len(sigma8s) * 12 * order * order)
        for i in range(len(sigma8s)):
            y[i * 12 * order * order:(i * 12 * order * order + 12 * order * order)] = sigma8s[i]
        if reshape_y:
            y = np.reshape(y, (len(sigma8s) * 12 * order * order, 1))
        if scramble:
            (x, y) = shuffle(x, y, random_state=0)
        if deepsphere_dataset:
            return LabeledDataset(x, y)
        return {"x": x, "y": y}
    if scramble:
        x = shuffle(x, random_state=0)
    return x


def lensing_channels(config):
    """
    Returns number of channels associated with a given lensing config string
    :param config: Lensing config string
    :return: int number of channels
    """
    if config == "g":
        return 2
    if config == "k":
        return 1
    if config == "kg":
        return 3
    if config == "":
        return 0
    print("Unknown config in deep_dss.utils.lensing_channels. Please try again.")


def split_lensing_maps_by_vals(sigma8s, config="g", coadd=True, corr=None, path_to_output=PATH_TO_OUTPUT, nest=True,
                               npix=NPIX,
                               pixarea=PIXEL_AREA,
                               density=DENSITY_KG, density_0=DENSITY_KG, multiplier=1.0,
                               ellip_sigma=ELLIP_SIGMA, noiseless=False, order=ORDER, scramble=False,
                               ground_truths=True, reshape_x=False, reshape_y=True, deepsphere_dataset=False):
    """
    Generates stacked array of partial-sky Gaussian-sampled maps for a list of $\\sigma_8$ values
    :param sigma8s: List of $\\sigma_8$ values
    :param coadd: If True, coadds correlated and uncorrelated signals
    :param corr: If coadd is False, determines whether correlated or uncorrelated signals are returned
    :param path_to_output: relative path to the FLASK output directory
    :param nest: True for NEST pixelization, False for RING
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param density: Source galaxy density, in arcmin^2, to use for noise application
    :param density_0: Baseline galaxy density, in arcmin^2, to scale distribution by
    :param multiplier: Scale factor used to amplify noise distribution
    :param ellip_sigma: Standard deviation representing uncertainty in ellipticity measurements
    :param noiseless: Does not take Gaussian draw if True
    :param order: ORDER giving the number of maps to split into (12*ORDER**2)
    :param config: "k" for convergence only, "g" for shear only, "kg" for convergence and shear
    :param scramble: If True, randomly scrambles the maps out of order
    :param ground_truths: True if corresponding labels should be returned as well
    :param reshape_x: If True, reshapes xs to have shape (.., .., 1)
    :param reshape_y: If True, reshapes ys to have shape (.., .., 1)
    :param deepsphere_dataset: Returns a DeepSphere LabeledDataset if true
    :return: Dictionary of DeepSphere datasets if deepsphere_dataset=True, maps and labels if ground_truths=True,
        stacked Numpy array of split, (rescaled) Gaussian-sampled maps otherwise
    """
    channels = lensing_channels(config)
    if channels == 1:
        x = np.empty((0, npix // (12 * order * order)))
    else:
        x = np.empty((0, npix // (12 * order * order), channels))
    for sigma8 in sigma8s:
        kg = split_lensing_maps_by_val(sigma8, coadd=coadd, corr=corr, path_to_output=path_to_output,
                                       nest=nest, npix=npix, pixarea=pixarea, density=density, density_0=density_0,
                                       multiplier=multiplier, ellip_sigma=ellip_sigma,
                                       noiseless=noiseless, order=order, config=config)
        x = np.vstack((x, kg))
    if channels == 1 and reshape_x:
        x = np.reshape(x, (len(sigma8s) * 12 * order * order, npix // (12 * order * order), 1))
    if ground_truths:
        y = np.zeros(len(sigma8s) * 12 * order * order)
        for i in range(len(sigma8s)):
            y[i * 12 * order * order:(i * 12 * order * order + 12 * order * order)] = sigma8s[i]
        if reshape_y:
            y = np.reshape(y, (len(sigma8s) * 12 * order * order, 1))
        if scramble:
            (x, y) = shuffle(x, y, random_state=0)
        if deepsphere_dataset:
            return LabeledDataset(x, y)
        return {"x": x, "y": y}
    if scramble:
        x = shuffle(x, random_state=0)
    return x


def split_count_and_lensing_maps_by_vals(sigma8s, config="g", name="map-f1z1.fits.gz", path_to_output=PATH_TO_OUTPUT,
                                         field=0,
                                         nest=True, npix=NPIX, pixarea=PIXEL_AREA, density_m=DENSITY_M,
                                         density_m_0=DENSITY_M,
                                         multiplier_m=1.0,
                                         bias=BIAS, normalize=True, noiseless_m=False, coadd=True, corr=None,
                                         density_kg=DENSITY_KG, density_kg_0=DENSITY_KG, multiplier_kg=1.0,
                                         ellip_sigma=ELLIP_SIGMA, noiseless_kg=False, order=ORDER, scramble=False,
                                         ground_truths=True, reshape_x=False, reshape_y=True, deepsphere_dataset=False):
    """
    Generates stacked array of partial-sky Poisson and Gaussian-sampled maps for a list of $\\sigma_8$ values
    :param sigma8s: List of $\\sigma_8$ values
    :param config: "k" for convergence only, "g" for shear only, "kg" for convergence and shear, with "c" added
    to the beginning for counts
    :param name: name of the map
    :param path_to_output: relative path to the FLASK output directory
    :param field: field of the map (for lensing maps with multiple fields)
    :param nest: True for NEST pixelization, False for RING
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param density_m: Tracer galaxy density, in arcmin^2, to use for noise application
    :param density_m_0: Baseline tracer galaxy density, in arcmin^2, to scale distribution by
    :param multiplier_m: Scale factor used to amplify shot noise distribution
    :param bias: Linear galaxy-matter bias
    :param normalize: True if resulting noise should be made to reflect a linear galaxy-matter bias of 1
    :param noiseless_m: Does not take Poisson draw if True
    :param coadd: If True, coadds correlated and uncorrelated signals
    :param corr: If coadd is False, determines whether correlated or uncorrelated signals are returned
    :param density_kg: Source galaxy density, in arcmin^2, to use for noise application
    :param density_kg_0: Baseline source galaxy density, in arcmin^2, to scale distribution by
    :param multiplier_kg: Scale factor used to amplify lensing noise distributions
    :param ellip_sigma: Standard deviation representing uncertainty in ellipticity measurements
    :param noiseless_kg: Does not take Gaussian draw if True
    :param order: ORDER giving the number of maps to split into (12*ORDER**2)
    :param scramble: If True, randomly scrambles the maps out of order
    :param ground_truths: True if corresponding labels should be returned as well
    :param reshape_x: If True, reshapes xs to have shape (.., .., 1)
    :param reshape_y: If True, reshapes ys to have shape (.., .., 1)
    :param deepsphere_dataset: Returns a DeepSphere LabeledDataset if true
    :return: Dictionary of DeepSphere datasets if deepsphere_dataset=True, maps and labels if ground_truths=True,
        stacked Numpy array of split, (rescaled) Poisson and Gaussian-sampled maps otherwise
    """
    counts = 0
    if config[0] == "c":
        counts = 1
        channels = 1 + lensing_channels(config[1:])
    else:
        channels = lensing_channels(config)
    if channels == 1:
        x = np.empty((0, npix // (12 * order * order)))
    else:
        x = np.empty((0, npix // (12 * order * order), channels))
    for sigma8 in sigma8s:
        if counts == 0:
            kg = split_lensing_maps_by_val(sigma8, coadd=coadd, corr=corr, path_to_output=path_to_output,
                                           nest=nest, npix=npix, pixarea=pixarea, density=density_kg,
                                           density_0=density_kg_0,
                                           multiplier=multiplier_kg, ellip_sigma=ellip_sigma,
                                           noiseless=noiseless_kg, order=order, config=config)
            x = np.vstack((x, kg))
        else:
            c = split_count_maps_by_val(sigma8, name=name, path_to_output=path_to_output, field=field,
                                        nest=nest, npix=npix, pixarea=pixarea, density=density_m,
                                        density_0=density_m_0,
                                        multiplier=multiplier_m,
                                        bias=bias, normalize=normalize, noiseless=noiseless_m,
                                        order=order)
            if channels == 1:
                x = np.vstack((x, c))
            else:
                c = np.reshape(c, (12 * order * order, npix // (12 * order * order), 1))
                kg = split_lensing_maps_by_val(sigma8, coadd=coadd, corr=corr, path_to_output=path_to_output,
                                               nest=nest, npix=npix, pixarea=pixarea, density=density_kg,
                                               density_0=density_kg_0,
                                               multiplier=multiplier_kg, ellip_sigma=ellip_sigma,
                                               noiseless=noiseless_kg, order=order, config=config[1:])
                if channels - counts == 1:
                    kg = np.reshape(kg, (12 * order * order, npix // (12 * order * order), 1))
                x = np.vstack((x, np.concatenate((c, kg), axis=2)))
    if channels == 1 and reshape_x:
        x = np.reshape(x, (len(sigma8s) * 12 * order * order, npix // (12 * order * order), 1))
    if ground_truths:
        y = np.zeros(len(sigma8s) * 12 * order * order)
        for i in range(len(sigma8s)):
            y[i * 12 * order * order:(i * 12 * order * order + 12 * order * order)] = sigma8s[i]
        if reshape_y:
            y = np.reshape(y, (len(sigma8s) * 12 * order * order, 1))
        if scramble:
            (x, y) = shuffle(x, y, random_state=0)
        if deepsphere_dataset:
            return LabeledDataset(x, y)
        return {"x": x, "y": y}
    if scramble:
        x = shuffle(x, random_state=0)
    return x


def split_count_maps_by_dataset(dataset, name="map-f1z1.fits.gz", path_to_output=PATH_TO_OUTPUT, field=0,
                                nest=True, npix=NPIX, pixarea=PIXEL_AREA, density=DENSITY_M, density_0=DENSITY_M,
                                multiplier=1.0,
                                bias=BIAS, normalize=True, noiseless=False, order=ORDER, scramble=False,
                                ground_truths=True, reshape_x=False, reshape_y=True, deepsphere_dataset=False):
    """
    Generates stacked array of partial-sky Poisson-sampled maps for a given data set
    :param dataset: String name of data-set to be used
    :param name: name of the map
    :param path_to_output: relative path to the FLASK output directory
    :param field: field of the map (for lensing maps with multiple fields)
    :param nest: True for NEST pixelization, False for RING
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param nest: True if "NEST" pixelization, False if "RING"
    :param density: Tracer galaxy density, in arcmin^2, to use for noise application
    :param density_0: Baseline galaxy density, in arcmin^2, to scale distribution by
    :param multiplier: Scale factor used to amplify noise distribution
    :param bias: Linear galaxy-matter bias
    :param normalize: True if resulting noise should be made to reflect a linear galaxy-matter bias of 1
    :param noiseless: Does not take Poisson draw if True
    :param order: ORDER giving the number of maps to split into (12*ORDER**2)
    :param scramble: If True, randomly scrambles the maps out of order
    :param ground_truths: True if corresponding labels should be returned as well
    :param reshape_y: If True, reshapes ys to have shape (.., .., 1)
    :param reshape_x: If True, reshapes xs to have shape (.., .., 1)
    :param deepsphere_dataset: Returns a DeepSphere LabeledDataset if true
    :return: Stacked Numpy array of split, (rescaled) Poisson-sampled maps
    """
    return split_count_maps_by_vals(cosmologies_list(dataset), name=name, path_to_output=path_to_output, field=field,
                                    nest=nest, npix=npix, pixarea=pixarea, density=density, density_0=density_0,
                                    multiplier=multiplier,
                                    bias=bias, normalize=normalize, noiseless=noiseless, order=order,
                                    scramble=scramble,
                                    ground_truths=ground_truths, reshape_x=reshape_x, reshape_y=reshape_y,
                                    deepsphere_dataset=deepsphere_dataset)


def split_lensing_maps_by_dataset(dataset, config="g", coadd=True, corr=None, path_to_output=PATH_TO_OUTPUT, nest=True,
                                  npix=NPIX,
                                  pixarea=PIXEL_AREA,
                                  density=DENSITY_KG, density_0=DENSITY_KG, multiplier=1.0,
                                  ellip_sigma=ELLIP_SIGMA, noiseless=False, order=ORDER, scramble=False,
                                  ground_truths=True, reshape_x=False, reshape_y=True, deepsphere_dataset=False):
    """
    Generates stacked array of partial-sky Gaussian-sampled maps for a given data-set
    :param dataset: String name of data-set to be used
    :param coadd: If True, coadds correlated and uncorrelated signals
    :param corr: If coadd is False, determines whether correlated or uncorrelated signals are returned
    :param path_to_output: relative path to the FLASK output directory
    :param nest: True for NEST pixelization, False for RING
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param density: Source galaxy density, in arcmin^2, to use for noise application
    :param density_0: Baseline galaxy density, in arcmin^2, to scale distribution by
    :param multiplier: Scale factor used to amplify noise distribution
    :param ellip_sigma: Standard deviation representing uncertainty in ellipticity measurements
    :param noiseless: Does not take Gaussian draw if True
    :param order: ORDER giving the number of maps to split into (12*ORDER**2)
    :param config: "k" for convergence only, "g" for shear only, "kg" for convergence and shear
    :param scramble: If True, randomly scrambles the maps out of order
    :param ground_truths: True if corresponding labels should be returned as well
    :param reshape_x: If True, reshapes xs to have shape (.., .., 1)
    :param reshape_y: If True, reshapes ys to have shape (.., .., 1)
    :param deepsphere_dataset: Returns a DeepSphere LabeledDataset if true
    :return: Dictionary of DeepSphere datasets if deepsphere_dataset=True, maps and labels if ground_truths=True,
        stacked Numpy array of split, (rescaled) Gaussian-sampled maps otherwise
    """
    return split_lensing_maps_by_vals(cosmologies_list(dataset), config=config, coadd=coadd, corr=corr,
                                      path_to_output=path_to_output, nest=nest,
                                      npix=npix,
                                      pixarea=pixarea,
                                      density=density, density_0=density_0, multiplier=multiplier,
                                      ellip_sigma=ellip_sigma, noiseless=noiseless, order=order, scramble=scramble,
                                      ground_truths=ground_truths, reshape_x=reshape_x, reshape_y=reshape_y,
                                      deepsphere_dataset=deepsphere_dataset)


def split_count_and_lensing_maps_by_dataset(dataset, config="g", name="map-f1z1.fits.gz", path_to_output=PATH_TO_OUTPUT,
                                            field=0,
                                            nest=True, npix=NPIX, pixarea=PIXEL_AREA, density_m=DENSITY_M,
                                            density_m_0=DENSITY_M,
                                            multiplier_m=1.0,
                                            bias=BIAS, normalize=True, noiseless_m=False, coadd=True, corr=None,
                                            density_kg=DENSITY_KG, density_kg_0=DENSITY_KG, multiplier_kg=1.0,
                                            ellip_sigma=ELLIP_SIGMA, noiseless_kg=False, order=ORDER, scramble=False,
                                            ground_truths=True, reshape_x=False, reshape_y=True,
                                            deepsphere_dataset=False):
    """
    Generates stacked array of partial-sky Poisson and Gaussian-sampled maps for a given data-set
    :param dataset: String name of data-set to be used
    :param config: "k" for convergence only, "g" for shear only, "kg" for convergence and shear,
    with "c" added to the beginning for counts
    :param name: name of the map
    :param path_to_output: relative path to the FLASK output directory
    :param field: field of the map (for lensing maps with multiple fields)
    :param nest: True for NEST pixelization, False for RING
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param density_m: Tracer galaxy density, in arcmin^2, to use for noise application
    :param density_m_0: Baseline tracer galaxy density, in arcmin^2, to scale distribution by
    :param multiplier_m: Scale factor used to amplify shot noise distribution
    :param bias: Linear galaxy-matter bias
    :param normalize: True if resulting noise should be made to reflect a linear galaxy-matter bias of 1
    :param noiseless_m: Does not take Poisson draw if True
    :param coadd: If True, coadds correlated and uncorrelated signals
    :param corr: If coadd is False, determines whether correlated or uncorrelated signals are returned
    :param density_kg: Source galaxy density, in arcmin^2, to use for noise application
    :param density_kg_0: Baseline source galaxy density, in arcmin^2, to scale distribution by
    :param multiplier_kg: Scale factor used to amplify lensing noise distributions
    :param ellip_sigma: Standard deviation representing uncertainty in ellipticity measurements
    :param noiseless_kg: Does not take Gaussian draw if True
    :param order: ORDER giving the number of maps to split into (12*ORDER**2)
    :param scramble: If True, randomly scrambles the maps out of order
    :param ground_truths: True if corresponding labels should be returned as well
    :param reshape_x: If True, reshapes xs to have shape (.., .., 1)
    :param reshape_y: If True, reshapes ys to have shape (.., .., 1)
    :param deepsphere_dataset: Returns a DeepSphere LabeledDataset if true
    :return: Dictionary of DeepSphere datasets if deepsphere_dataset=True, maps and labels if ground_truths=True,
        stacked Numpy array of split, (rescaled) Poisson and Gaussian-sampled maps otherwise
    """
    return split_count_and_lensing_maps_by_vals(cosmologies_list(dataset), config=config, name=name,
                                                path_to_output=path_to_output,
                                                field=field,
                                                nest=nest, npix=npix, pixarea=pixarea, density_m=density_m,
                                                density_m_0=density_m_0,
                                                multiplier_m=multiplier_m,
                                                bias=bias, normalize=normalize, noiseless_m=noiseless_m, coadd=coadd,
                                                corr=corr,
                                                density_kg=density_kg, density_kg_0=density_kg_0,
                                                multiplier_kg=multiplier_kg,
                                                ellip_sigma=ellip_sigma, noiseless_kg=noiseless_kg, order=order,
                                                scramble=scramble,
                                                ground_truths=ground_truths, reshape_x=reshape_x, reshape_y=reshape_y,
                                                deepsphere_dataset=deepsphere_dataset)


def split_count_maps_by_datasets(val=False, name="map-f1z1.fits.gz", path_to_output=PATH_TO_OUTPUT,
                                 field=0,
                                 nest=True, npix=NPIX, pixarea=PIXEL_AREA, density=DENSITY_M, density_0=DENSITY_M,
                                 multiplier=1.0,
                                 bias=BIAS, normalize=True, noiseless=False, order=ORDER, scramble=False,
                                 ground_truths=True, reshape_x=False, reshape_y=True, deepsphere_dataset=False):
    """
    Returns a data dictionary containing Poisson-sampled maps for each data-set
    :param val: If True, validation set is included in dataset_names()
    :param name: name of the map
    :param path_to_output: relative path to the FLASK output directory
    :param field: field of the map (for lensing maps with multiple fields)
    :param nest: True for NEST pixelization, False for RING
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param nest: True if "NEST" pixelization, False if "RING"
    :param density: Tracer galaxy density, in arcmin^2, to use for noise application
    :param density_0: Baseline galaxy density, in arcmin^2, to scale distribution by
    :param multiplier: Scale factor used to amplify noise distribution
    :param bias: Linear galaxy-matter bias
    :param normalize: True if resulting noise should be made to reflect a linear galaxy-matter bias of 1
    :param noiseless: Does not take Poisson draw if True
    :param order: ORDER giving the number of maps to split into (12*ORDER**2)
    :param scramble: If True, randomly scrambles the maps out of order
    :param ground_truths: True if corresponding labels should be returned as well
    :param reshape_y: If True, reshapes ys to have shape (.., .., 1)
    :param reshape_x: If True, reshapes xs to have shape (.., .., 1)
    :param deepsphere_dataset: Returns a DeepSphere LabeledDataset if true
    :return: Dictionary of DeepSphere datasets if deepsphere_dataset=True, maps and labels if ground_truths=True,
        stacked Numpy array of split, (rescaled) Poisson and Gaussian-sampled maps otherwise
    """
    data = {}
    for dataset in dataset_names(val=val):
        data[dataset] = split_count_maps_by_dataset(dataset=dataset, name=name, path_to_output=path_to_output,
                                                    field=field,
                                                    nest=nest, npix=npix, pixarea=pixarea, density=density,
                                                    density_0=density_0, multiplier=multiplier,
                                                    bias=bias, normalize=normalize, noiseless=noiseless, order=order,
                                                    scramble=scramble,
                                                    ground_truths=ground_truths, reshape_x=reshape_x,
                                                    reshape_y=reshape_y, deepsphere_dataset=deepsphere_dataset)
    return data


def split_lensing_maps_by_datasets(val=False, config="g", coadd=True, corr=None, path_to_output=PATH_TO_OUTPUT,
                                   nest=True,
                                   npix=NPIX,
                                   pixarea=PIXEL_AREA,
                                   density=DENSITY_KG, density_0=DENSITY_KG, multiplier=1.0,
                                   ellip_sigma=ELLIP_SIGMA, noiseless=False, order=ORDER, scramble=False,
                                   ground_truths=True, reshape_x=False, reshape_y=True, deepsphere_dataset=False):
    """
    Returns a data dictionary containing Gaussian-sampled maps for each data-set
    :param val: If True, validation set is included in dataset_names()
    :param coadd: If True, coadds correlated and uncorrelated signals
    :param corr: If coadd is False, determines whether correlated or uncorrelated signals are returned
    :param path_to_output: relative path to the FLASK output directory
    :param nest: True for NEST pixelization, False for RING
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param density: Source galaxy density, in arcmin^2, to use for noise application
    :param density_0: Baseline galaxy density, in arcmin^2, to scale distribution by
    :param multiplier: Scale factor used to amplify noise distribution
    :param ellip_sigma: Standard deviation representing uncertainty in ellipticity measurements
    :param noiseless: Does not take Gaussian draw if True
    :param order: ORDER giving the number of maps to split into (12*ORDER**2)
    :param config: "k" for convergence only, "g" for shear only, "kg" for convergence and shear
    :param scramble: If True, randomly scrambles the maps out of order
    :param ground_truths: True if corresponding labels should be returned as well
    :param reshape_x: If True, reshapes xs to have shape (.., .., 1)
    :param reshape_y: If True, reshapes ys to have shape (.., .., 1)
    :param deepsphere_dataset: Returns a DeepSphere LabeledDataset if true
    :return: Dictionary of DeepSphere datasets if deepsphere_dataset=True, maps and labels if ground_truths=True,
        stacked Numpy array of split, (rescaled) Poisson and Gaussian-sampled maps otherwise
    """
    data = {}
    for dataset in dataset_names(val=val):
        data[dataset] = split_lensing_maps_by_dataset(dataset, config=config, coadd=coadd, corr=corr,
                                                      path_to_output=path_to_output, nest=nest,
                                                      npix=npix,
                                                      pixarea=pixarea,
                                                      density=density, density_0=density_0, multiplier=multiplier,
                                                      ellip_sigma=ellip_sigma, noiseless=noiseless, order=order,
                                                      scramble=scramble,
                                                      ground_truths=ground_truths, reshape_x=reshape_x,
                                                      reshape_y=reshape_y, deepsphere_dataset=deepsphere_dataset)
    return data


def split_count_and_lensing_maps_by_datasets(val=False, config="g", name="map-f1z1.fits.gz",
                                             path_to_output=PATH_TO_OUTPUT,
                                             field=0,
                                             nest=True, npix=NPIX, pixarea=PIXEL_AREA, density_m=DENSITY_M,
                                             density_m_0=DENSITY_M,
                                             multiplier_m=1.0,
                                             bias=BIAS, normalize=True, noiseless_m=False, coadd=True, corr=None,
                                             density_kg=DENSITY_KG, density_kg_0=DENSITY_KG, multiplier_kg=1.0,
                                             ellip_sigma=ELLIP_SIGMA, noiseless_kg=False, order=ORDER, scramble=False,
                                             ground_truths=True, reshape_x=False, reshape_y=True,
                                             deepsphere_dataset=False):
    """
    Returns a data dictionary containing Poisson Gaussian-sampled maps for each data-set
    :param val: If True, validation set is included in dataset_names()
    :param config: "k" for convergence only, "g" for shear only, "kg" for convergence and shear,
    with "c" added to the beginning for counts
    :param name: name of the map
    :param path_to_output: relative path to the FLASK output directory
    :param field: field of the map (for lensing maps with multiple fields)
    :param nest: True for NEST pixelization, False for RING
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param density_m: Tracer galaxy density, in arcmin^2, to use for noise application
    :param density_m_0: Baseline tracer galaxy density, in arcmin^2, to scale distribution by
    :param multiplier_m: Scale factor used to amplify shot noise distribution
    :param bias: Linear galaxy-matter bias
    :param normalize: True if resulting noise should be made to reflect a linear galaxy-matter bias of 1
    :param noiseless_m: Does not take Poisson draw if True
    :param coadd: If True, coadds correlated and uncorrelated signals
    :param corr: If coadd is False, determines whether correlated or uncorrelated signals are returned
    :param density_kg: Source galaxy density, in arcmin^2, to use for noise application
    :param density_kg_0: Baseline source galaxy density, in arcmin^2, to scale distribution by
    :param multiplier_kg: Scale factor used to amplify lensing noise distributions
    :param ellip_sigma: Standard deviation representing uncertainty in ellipticity measurements
    :param noiseless_kg: Does not take Gaussian draw if True
    :param order: ORDER giving the number of maps to split into (12*ORDER**2)
    :param scramble: If True, randomly scrambles the maps out of order
    :param ground_truths: True if corresponding labels should be returned as well
    :param reshape_x: If True, reshapes xs to have shape (.., .., 1)
    :param reshape_y: If True, reshapes ys to have shape (.., .., 1)
    :param deepsphere_dataset: Returns a DeepSphere LabeledDataset if true
    :return: Dictionary of DeepSphere datasets if deepsphere_dataset=True, maps and labels if ground_truths=True,
        stacked Numpy array of split, (rescaled) Poisson and Gaussian-sampled maps otherwise
    """
    data = {}
    for dataset in dataset_names(val=val):
        data[dataset] = split_count_and_lensing_maps_by_vals(dataset, config=config, name=name,
                                                             path_to_output=path_to_output,
                                                             field=field,
                                                             nest=nest, npix=npix, pixarea=pixarea, density_m=density_m,
                                                             density_m_0=density_m_0,
                                                             multiplier_m=multiplier_m,
                                                             bias=bias, normalize=normalize, noiseless_m=noiseless_m,
                                                             coadd=coadd,
                                                             corr=corr,
                                                             density_kg=density_kg, density_kg_0=density_kg_0,
                                                             multiplier_kg=multiplier_kg,
                                                             ellip_sigma=ellip_sigma, noiseless_kg=noiseless_kg,
                                                             order=order,
                                                             scramble=scramble,
                                                             ground_truths=ground_truths, reshape_x=reshape_x,
                                                             reshape_y=reshape_y,
                                                             deepsphere_dataset=deepsphere_dataset)
    return data


def list_tracer_noise_scales(handpicked=False, num=6, noiseless=True):
    """
    Generate a list of noise levels (tracer galaxy densities in arcmin^2) at which to evaluate model predictions.
    :param noiseless: If True, includes noiseless case.
    :param num: Number of noise levels (exluding noiseless case) to generate
    :param handpicked: If True, return handpicked list of noise-levels. Use geomspace vals if false
    :return: A list of noise levels (-1 for noiseless)
    """
    if handpicked:
        if noiseless:
            return np.array([0.04377, 0.12, 0.3, 4, 50, -1])
        return np.array([0.04377, 0.12, 1, 10, 100, 1000])
    if noiseless:
        return np.append(np.geomspace(0.04377, 100, num=num), -1)
    return np.geomspace(0.04377, 1000, num=num)
