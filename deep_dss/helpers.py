import numpy as np
import healpy as hp
import pandas as pd
from numba import jit
from sklearn.utils import shuffle

from deepsphere import experiment_helper
from deepsphere.data import LabeledDataset


# Constants


def set_constants():
    """
    Sets constants for future functions (especially accelerated ones)
    :return: NSIDE, NPIX, PIXEL_AREA (in arcmin^2), ORDER, BIAS, DENSITY_M, DENSITY_KG and ELLIP_SIGMA
    """
    nside = 1024
    npix = hp.nside2npix(nside)
    pixel_area = hp.nside2pixarea(nside, degrees=True) * 3600
    order = 2
    bias = 1.54
    density_m = 0.04377
    density_kg = 10
    ellip_sigma = 0.25
    return nside, npix, pixel_area, order, bias, density_m, density_kg, ellip_sigma


(NSIDE, NPIX, PIXEL_AREA, ORDER, BIAS, DENSITY_M, DENSITY_KG, ELLIP_SIGMA) = set_constants()


# MACHINE = "LOCAL"


# MACHINE = "BRIDGES"


def set_paths():
    """
    Sets directory paths based on the machine being used
    :return: PATH_TO_INPUT, PATH_TO_OUTPUT, PATH_TO_CHECKPOINTS and PATH_TO_VAL
    """
    path_to_input = "../data/flaskv3/input/"
    path_to_output = "../data/flaskv3/output/"
    path_to_checkpoints = ""
    path_to_val = "../validation_101.npz"

    return path_to_input, path_to_output, path_to_checkpoints, path_to_val


(PATH_TO_INPUT, PATH_TO_OUTPUT, PATH_TO_CHECKPOINTS, PATH_TO_VAL) = set_paths()


# C(l) helper functions

def path_to_cl(sigma8, name="f1z1f1z1", path_to_input=PATH_TO_INPUT):
    """
    Returns relative path to FLASK input C(l) generated by trough_lenser
    :param sigma8:Value of $\\sigma_8$ used to generate the C(l)s
    :param name: Name of the C(l)
    :param path_to_input: Path to flask101 input directory, ending in / (default assumes data folder in repo)
    :return: relative path string to the appropriate C(l) file
    """
    return path_to_input + "dss-{0}/dss-{0}-Cl-{1}.dat".format(round(sigma8, 5), name)


def load_cl_from_path(path, lmax=10000):
    """
    Generate pandas dataframe for a given input C(l) file
    :param path: path to C(l) file
    :param lmax: maximum l value in C(l) file
    :return: data frame containing vector of ls and corresponding C(l) values
    """
    data = pd.read_csv(path, sep=' ', header=None)
    data.columns = ['L', 'CL']
    data.index = np.arange(lmax + 1)
    return data


def load_cl_from_val(sigma8, lmax=9999, name="f1z1f1z1", path_to_input=PATH_TO_INPUT):
    """
    Wrapper function to return pandas data frame for a specified C(l)
    :param sigma8: Value of $\\sigma_8$ used to generate the C(l)s
    :param lmax: maximum l value in C(l) file
    :param name: Name of the C(l)
    :param path_to_input: Path to flask101 input directory, ending in / (default assumes data folder in repo)
    :return: data frame containing vector of ls and corresponding C(l) values
    """
    return load_cl_from_path(path_to_cl(sigma8, name=name, path_to_input=path_to_input), lmax=lmax)


# Descriptions of different data sets

def full_cosmologies_list():
    """
    Return the full list of $\\sigma_8$ values in the simulated data
    :return: A numpy array covering all 101 $\\sigma_8$ values in the flat prior
    """
    return np.linspace(0.5, 1.2, num=201)


def lite_train_cosmologies_list():
    """
    Return the list of $\\sigma_8$ values used in training lite
    :return: A numpy array of 16 $\\sigma_8$ values
    """
    # return np.array([0.5, 0.57, 0.71, 0.78, 0.92, 0.99, 1.13, 1.2])
    return np.array([0.535, 0.605, 0.64, 0.675, 0.71, 0.78,
                     0.815, 0.85, 0.885, 0.955, 0.99, 1.025, 1.06,
                     1.13, 1.165, 1.2])


def lite_test_cosmologies_list():
    """
    Return the list of $\\sigma_8$ values used in testing lite
    :return: A numpy array of 4 $\\sigma_8$ values
    """
    # return np.array([0.64, 0.85, 1.06])
    return np.array([0.57, 0.745, 0.92, 1.095])


def q1_cosmologies_list():
    """
    Return the list of $\\sigma_8$ values used in training Q1
    :return: A numpy array of 20 $\\sigma_8$ values
    """
    return np.array([0.7345, 0.969, 0.6435, 0.654, 1.1895, 1.06, 1.109, 0.703,
                     1.032, 1.1615, 1.0705, 0.759, 0.5175, 0.885, 0.9515, 0.6295,
                     0.7415, 0.605, 0.5875, 0.7205, 0.7065, 1.1685, 0.773, 1.179,
                     0.577, 0.857, 1.1195, 1.123, 1.1965, 0.843, 0.7975, 0.5245,
                     1.172, 0.99, 0.892, 0.7485, 0.955, 0.528, 1.0845, 1.1265,
                     1.0005, 0.8535, 0.5, 0.9165, 0.5105])


def q2_cosmologies_list():
    """
    Return the list of $\\sigma_8$ values used in training Q2
    :return: A numpy array of 20 $\\sigma_8$ values
    """
    return np.array([0.5035, 1.025, 0.6995, 0.5385, 0.6015, 1.018, 0.829, 0.927,
                     0.7905, 1.095, 0.9655, 0.5595, 1.165, 0.6645, 0.724, 0.6155,
                     1.039, 0.78, 0.941, 0.633, 1.186, 1.193, 1.0635, 0.8675,
                     1.151, 0.8815, 1.0775, 0.563, 0.6925, 0.7555, 1.1755, 1.1335,
                     0.696, 0.801, 0.864, 0.598, 1.158, 0.8955, 0.5315, 1.0355,
                     0.899, 1.046, 0.542, 1.0215, 1.1825])


def q3_cosmologies_list():
    """
    Return the list of $\\sigma_8$ values used in training Q3
    :return: A numpy array of 20 $\\sigma_8$ values
    """
    return np.array([0.8395, 0.689, 0.8465, 0.6365, 1.0145, 0.6785, 1.004, 1.1055,
                     1.053, 0.57, 1.0495, 0.8255, 0.668, 1.137, 0.5805, 0.9235,
                     0.619, 0.661, 0.7695, 0.7765, 0.9375, 0.836, 0.591, 0.906,
                     1.1545, 0.8745, 0.766, 0.675, 0.8885, 0.9095, 1.102, 0.92,
                     0.556, 1.011, 1.0075, 0.6225, 0.5455, 0.6715, 0.626, 0.983,
                     0.738, 0.71, 0.8325, 0.962, 0.822])


def q4_cosmologies_list():
    """
    Return the list of $\\sigma_8$ values used in training Q4
    :return: A numpy array of 20 $\\sigma_8$ values
    """
    return np.array([1.1475, 0.5525, 0.85, 0.9445, 0.7835, 0.549, 0.794, 0.815,
                     0.9585, 0.6575, 0.9935, 1.067, 0.8605, 0.514, 1.0985, 1.0285,
                     0.612, 1.1405, 1.081, 0.948, 0.6085, 0.934, 0.731, 0.7275,
                     0.5945, 0.913, 0.787, 1.0425, 0.7135, 0.808, 1.074, 0.8185,
                     0.6505, 0.9725, 0.976, 0.9025, 0.8045, 0.584, 0.535, 0.717,
                     0.64, 1.1125, 0.745, 0.7625, 0.521])


def test_cosmologies_list():
    """
    Return the list of $\\sigma_8$ values used in testing
    :return: A numpy array of 21 $\\sigma_8$ values
    """
    return np.array([1.144, 0.9865, 0.6855, 1.088, 1.116, 0.682, 1.0565, 0.752,
                     0.9305, 1.0915, 0.5665, 0.647, 0.871, 0.9795, 1.2, 1.13,
                     0.5735, 0.997, 0.878, 0.507, 0.8115])


def cosmologies_list(dataset):
    """
    Returns list of $\\sigma_8$ values for an input data set
    :param dataset: Name of data set
    :return: Numpy array of 4, 7, 20, 21, or 101 values
    """
    if dataset == "Q1":
        return q1_cosmologies_list()
    if dataset == "Q2":
        return q2_cosmologies_list()
    if dataset == "Q3":
        return q3_cosmologies_list()
    if dataset == "Q4":
        return q4_cosmologies_list()
    if dataset == "TEST":
        return test_cosmologies_list()
    if dataset == "FULL":
        return full_cosmologies_list()
    if dataset == "TRAINLITE":
        return lite_train_cosmologies_list()
    if dataset == "TESTLITE":
        return lite_test_cosmologies_list()
    print("Invalid data set specification. Please try again")


def dataset_names(val=False):
    """
    Returns list of data set names
    :param val: Whether or not to include the validation set
    :return: List of strings
    """
    if val:
        return ["Q1", "Q2", "Q3", "Q4", "TEST", "VAL"]
    return ["Q1", "Q2", "Q3", "Q4", "TEST"]


# Map loading functions

def path_to_map(sigma8, name="map-f1z1.fits.gz", path_to_output=PATH_TO_OUTPUT, gaussian=False):
    """
    Return relative path to Healpix map given $\\sigma_8$
    :param gaussian: If True, returns Gaussian map. Returns log-normal if False.
    :param sigma8: Value of $\\sigma_8$$ from which the map was generated
    :param name: Name of the map file
    :param path_to_output: Relative path to the FLASK output directory
    :return: String with path
    """
    if gaussian is True:
        return path_to_output + "dss-gauss-{0}/dss-gauss-{0}-{1}".format(round(sigma8, 5), name)
    return path_to_output + "dss-{0}/dss-{0}-{1}".format(round(sigma8, 5), name)


def load_map_by_path(path, field=0, nest=True):
    """
    Returns HEALPIX map located at a given path
    :param path: relative path to the map
    :param field: field of the map (for lensing maps with multiple fields)
    :param nest: True for NEST pixellization, False for RING
    :return: Numpy array with map
    """
    return hp.read_map(path, field=field, nest=nest)


def load_map_by_val(sigma8, name="map-f1z1.fits.gz", path_to_output=PATH_TO_OUTPUT, field=0, nest=True, gaussian=False):
    """
    Returns HEALPIX map for FLASK realization of a given $\\sigma_8$ value
    :param gaussian: If True, returns Gaussian map. Returns log-normal if False.
    :param sigma8: Value of $\\sigma_8$
    :param name: name of the map
    :param path_to_output: relative path to the FLASK output directory
    :param field: field of the map (for lensing maps with multiple fields)
    :param nest: True for NEST pixelization, False for RING
    :return: Numpy array with map
    """
    return load_map_by_path(path_to_map(sigma8, name=name, path_to_output=path_to_output, gaussian=gaussian),
                            field=field, nest=nest)


def load_shear_maps_by_val(sigma8, coadd=True, corr=None, path_to_output=PATH_TO_OUTPUT, nest=True, gaussian=False):
    """
    Returns list of two HEALPIX maps (for $\\gamma_1$ and $\\gamma_2$) for FLASK realization of a
    given $\\sigma_8$ value
    :param gaussian: If True, returns Gaussian map. Returns log-normal if False.
    :param sigma8: Value of $\\sigma_8$
    :param coadd: If True, coadds correlated and uncorrelated signals
    :param corr: If coadd is False, determines whether correlated or uncorrelated signals are returned
    :param path_to_output: relative path to the FLASK output directory
    :param nest: True for NEST pixelization, False for RING
    :return: List of two Numpy arrays
    """
    if coadd:
        return [load_map_by_val(sigma8, name="kappa-gamma-f2z1.fits.gz", path_to_output=path_to_output, field=i + 1,
                                nest=nest, gaussian=gaussian) + load_map_by_val(sigma8, name="kappa-gamma-f2z2.fits.gz",
                                                                                path_to_output=path_to_output,
                                                                                field=i + 1, nest=nest,
                                                                                gaussian=gaussian) for
                i in
                range(2)]
    if corr:
        return [load_map_by_val(sigma8, name="kappa-gamma-f2z1.fits.gz", path_to_output=path_to_output, field=i + 1,
                                nest=nest, gaussian=gaussian) for i in range(2)]
    return [load_map_by_val(sigma8, name="kappa-gamma-f2z2.fits.gz", path_to_output=path_to_output, field=i + 1,
                            nest=nest, gaussian=gaussian) for i in range(2)]


def load_convergence_map_by_val(sigma8, coadd=True, corr=None, path_to_output=PATH_TO_OUTPUT, nest=True,
                                gaussian=False):
    """
    Returns HEALPIX map (for $\\kappa$) for FLASK realization of a given $\\sigma_8$ value
    :param gaussian: If True, returns Gaussian map. Returns log-normal if False.
    :param sigma8: Value of $\\sigma_8$
    :param coadd: If True, coadds correlated and uncorrelated signals
    :param corr: If coadd is False, determines whether correlated or uncorrelated signals are returned
    :param path_to_output: relative path to the FLASK output directory
    :param nest: True for NEST pixelization, False for RING
    :return: Numpy array storing HEALPIX map
    """
    if coadd:
        return load_map_by_val(sigma8, name="kappa-gamma-f2z1.fits.gz", path_to_output=path_to_output, field=0,
                               nest=nest, gaussian=gaussian) + load_map_by_val(sigma8, name="kappa-gamma-f2z2.fits.gz",
                                                                               path_to_output=path_to_output, field=0,
                                                                               nest=nest, gaussian=gaussian)
    if corr:
        return load_map_by_val(sigma8, name="kappa-gamma-f2z1.fits.gz", path_to_output=path_to_output, field=0,
                               nest=nest, gaussian=gaussian)
    return load_map_by_val(sigma8, name="kappa-gamma-f2z2.fits.gz", path_to_output=path_to_output, field=0,
                           nest=nest, gaussian=gaussian)


@jit(nopython=True)
def accelerated_noiseless_counts(m, npix=NPIX, pixarea=PIXEL_AREA,
                                 density=DENSITY_M, density_0=DENSITY_M, multiplier=1.0, bias=BIAS, rand_bias=False,
                                 prior_low=0.8, prior_high=3.0,
                                 normalize=True):
    """
    Returns new version of input map without any Poissonian shot noise applied.
    :param prior_high: Upper limit of flat prior for linear bias. Used only if rand_bias is True.
    :param prior_low: Lower limit of flat prior for linear bias. Used only if rand_bias is True.
    :param rand_bias: If True, applies random linear bias within a certain flat prior to raw map
    :param m: FLASK output map of galaxy density contrast, $\\delta_g$
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param density: Tracer galaxy density, in arcmin^2, to use for noise application
    :param density_0: Baseline galaxy density, in arcmin^2, to scale distribution by
    :param multiplier: Scale factor used to amplify noise distribution
    :param bias: Linear galaxy-matter bias
    :param normalize: True if resulting noise should be made to reflect a linear galaxy-matter bias of 1
    :return: A noiseless output map
    """
    x = np.zeros(m.shape)
    if rand_bias is True:
        b = np.random.uniform(prior_low, prior_high)
    else:
        b = bias
    for i in range(npix):
        if normalize:
            x[i] = multiplier * (density_0 / density) * (density * pixarea * (1 + m[i]))
        else:
            x[i] = multiplier * (density_0 / density) * (density * pixarea * (1 + b * m[i]))
    return x


@jit(nopython=True)
def accelerated_noiseless_shear(g, npix=NPIX, multiplier=1.0):
    """
    Returns new version of input maps without any Gaussian shape noise applied.
    :param g: FLASK output maps of lensing shear, $\\gamma_1$ and $\\gamma_2$
    :param npix: Number of pixels in map
    :param multiplier: Scale factor used to amplify noise distribution
    :return: A noiseless list of output maps
    """
    x = [np.zeros(g[i].shape) for i in range(2)]
    for c in range(2):
        for i in range(npix):
            x[c][i] = multiplier * g[c][i]
    return x


@jit(nopython=True)
def accelerated_noiseless_convergence(k, npix=NPIX, multiplier=1.0):
    """
    Returns new version of input map without any Gaussian shape noise applied.
    :param k: FLASK output maps of lensing convergence, $\\kappa$
    :param npix: Number of pixels in map
    :param multiplier: Scale factor used to amplify noise distribution
    :return: A noiseless output map
    """
    x = np.zeros(k.shape)
    for i in range(npix):
        x[i] = multiplier * k[i]
    return x


@jit(nopython=True)
def accelerated_poissonian_shot_noise(m, npix=NPIX, pixarea=PIXEL_AREA,
                                      density=DENSITY_M, density_0=DENSITY_M, multiplier=1.0, bias=BIAS,
                                      rand_bias=False,
                                      prior_low=0.8, prior_high=3.0,
                                      normalize=True):
    """
    Returns new version of input map with a specified level of Poissonian shot noise applied.
    :param prior_high: Upper limit of flat prior for linear bias. Used only if rand_bias is True.
    :param prior_low: Lower limit of flat prior for linear bias. Used only if rand_bias is True.
    :param rand_bias: If True, applies random linear bias within a certain flat prior to raw map
    :param m: FLASK output map of galaxy density contrast, $\\delta_g$
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param density: Tracer galaxy density, in arcmin^2, to use for noise application
    :param density_0: Baseline galaxy density, in arcmin^2, to scale distribution by
    :param multiplier: Scale factor used to amplify noise distribution
    :param bias: Linear galaxy-matter bias
    :param normalize: True if resulting noise should be made to reflect a linear galaxy-matter bias of 1
    :return: A noisy Poisson-sampled output map
    """
    x = np.zeros(m.shape)
    if rand_bias is True:
        b = np.random.uniform(prior_low, prior_high)
    else:
        b = bias
    for i in range(npix):
        if normalize:
            x[i] = multiplier * (density_0 / density) * np.random.poisson(density * pixarea * (1 + m[i]))
        else:
            x[i] = multiplier * (density_0 / density) * np.random.poisson(density * pixarea * (1 + b * m[i]))
    return x


@jit(nopython=True)
def accelerated_gaussian_shear_noise(g, npix=NPIX, pixarea=PIXEL_AREA,
                                     density=DENSITY_KG, density_0=DENSITY_KG, multiplier=1.0,
                                     ellip_sigma=ELLIP_SIGMA):
    """
    Returns new version of input map with a specified level of Gaussian shape noise applied.
    :param ellip_sigma: Standard deviation representing uncertainty in ellipticity measurements
    :param g: FLASK output maps of lensing shear ($\\gamma_1$ and $\\gamma_2$)
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param density: Source galaxy density, in arcmin^2, to use for noise application
    :param density_0: Baseline galaxy density, in arcmin^2, to scale distribution by
    :param multiplier: Scale factor used to amplify noise distribution
    :return: A list of two noisy Gaussian-sampled output maps
    """
    x = [np.zeros(g[i].shape) for i in range(2)]
    for c in range(2):
        for i in range(npix):
            x[c][i] = multiplier * (density_0 / density) * np.random.normal(loc=g[c][i], scale=ellip_sigma / np.sqrt(
                pixarea * density))
    return x


@jit(nopython=True)
def accelerated_gaussian_convergence_noise(k, npix=NPIX, pixarea=PIXEL_AREA,
                                           density=DENSITY_KG, density_0=DENSITY_KG, multiplier=1.0,
                                           ellip_sigma=ELLIP_SIGMA):
    """
    Returns new version of input map with a specified level of Gaussian shape noise applied.
    (Modeled after https://arxiv.org/pdf/2007.06529.pdf)
    :param k: FLASK output maps of lensing convergence ($\\kappa$)
    :param ellip_sigma: Standard deviation representing uncertainty in ellipticity measurements
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param density: Source galaxy density, in arcmin^2, to use for noise application
    :param density_0: Baseline galaxy density, in arcmin^2, to scale distribution by
    :param multiplier: Scale factor used to amplify noise distribution
    :return: A noisy Gaussian-sampled output map
    """
    x = np.zeros(k.shape)
    for i in range(npix):
        x[i] = multiplier * (density_0 / density) * np.random.normal(loc=k[i], scale=ellip_sigma / np.sqrt(
            2 * pixarea * density))
    return x


def count_map_by_val(sigma8, name="map-f1z1.fits.gz", path_to_output=PATH_TO_OUTPUT, field=0, nest=True,
                     npix=NPIX, pixarea=PIXEL_AREA, density=DENSITY_M, density_0=DENSITY_M, multiplier=1.0,
                     bias=BIAS, rand_bias=False, prior_low=0.8, prior_high=3.0, normalize=True, noiseless=False,
                     gaussian=False):
    """
    Loads galaxy density contrast map for a given $\\sigma_8$ and applies Poissonian shot noise
    :param gaussian: If True, returns Gaussian map. Returns log-normal if False.
    :param prior_high: Upper limit of flat prior for linear bias. Used only if rand_bias is True.
    :param prior_low: Lower limit of flat prior for linear bias. Used only if rand_bias is True.
    :param rand_bias: If True, applies random linear bias within a certain flat prior to raw map
    :param sigma8: Value of $\\sigma_8$
    :param name: name of the map
    :param path_to_output: relative path to the FLASK output directory
    :param field: field of the map (for lensing maps with multiple fields)
    :param nest: True for NEST pixellization, False for RING
    :return: Numpy array with map
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param nest: True if "NEST" pixelization, False if "RING"
    :param density: Tracer galaxy density, in arcmin^2, to use for noise application
    :param density_0: Baseline galaxy density, in arcmin^2, to scale distribution by
    :param multiplier: Scale factor used to amplify noise distribution
    :param bias: Linear galaxy-matter bias
    :param normalize: True if resulting noise should be made to reflect a linear galaxy-matter bias of 1
    :param noiseless: Does not take Poisson draw if True
    :return: A noisy Poisson-sampled output map
    """
    if noiseless:
        return accelerated_noiseless_counts(
            load_map_by_val(sigma8, name=name, path_to_output=path_to_output, field=field, nest=nest,
                            gaussian=gaussian),
            npix=npix, pixarea=pixarea, density=density, density_0=density_0, multiplier=multiplier, bias=bias,
            normalize=normalize, rand_bias=rand_bias, prior_low=prior_low, prior_high=prior_high)
    return accelerated_poissonian_shot_noise(
        load_map_by_val(sigma8, name=name, path_to_output=path_to_output, field=field, nest=nest, gaussian=gaussian),
        npix=npix, pixarea=pixarea, density=density, density_0=density_0, multiplier=multiplier, bias=bias,
        normalize=normalize, rand_bias=rand_bias, prior_low=prior_low, prior_high=prior_high)


def shear_maps_by_val(sigma8, coadd=True, corr=None, path_to_output=PATH_TO_OUTPUT, nest=True, npix=NPIX,
                      pixarea=PIXEL_AREA,
                      density=DENSITY_KG, density_0=DENSITY_KG, multiplier=1.0,
                      ellip_sigma=ELLIP_SIGMA, noiseless=False, gaussian=False):
    """
    Loads lensing shear maps for a given $\\sigma_8$ and applies Gaussian shape noise
    :param gaussian: If True, returns Gaussian map. Returns log-normal if False.
    :param noiseless: Does not take Gaussian draw if True
    :param sigma8: Value of $\\sigma_8$
    :param coadd: If True, coadds correlated and uncorrelated signals
    :param corr: If coadd is False, determines whether correlated or uncorrelated signals are returned
    :param path_to_output: relative path to the FLASK output directory
    :param nest: True for NEST pixelization, False for RING
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param density: Source galaxy density, in arcmin^2, to use for noise application
    :param density_0: Baseline galaxy density, in arcmin^2, to scale distribution by
    :param multiplier: Scale factor used to amplify noise distribution
    :param ellip_sigma: Standard deviation representing uncertainty in ellipticity measurements
    :return: A list of two noisy Gaussian-sampled output maps
    """
    if noiseless:
        return accelerated_noiseless_shear(
            load_shear_maps_by_val(sigma8, coadd=coadd, corr=corr, path_to_output=path_to_output, nest=nest,
                                   gaussian=gaussian), npix=npix,
            multiplier=multiplier)
    return accelerated_gaussian_shear_noise(
        load_shear_maps_by_val(sigma8, coadd=coadd, corr=corr, path_to_output=path_to_output, nest=nest,
                               gaussian=gaussian), npix=npix,
        pixarea=pixarea, density=density, density_0=density_0, multiplier=multiplier, ellip_sigma=ellip_sigma)


def convergence_map_by_val(sigma8, coadd=True, corr=None, path_to_output=PATH_TO_OUTPUT, nest=True, npix=NPIX,
                           pixarea=PIXEL_AREA,
                           density=DENSITY_KG, density_0=DENSITY_KG, multiplier=1.0,
                           ellip_sigma=ELLIP_SIGMA, noiseless=False, gaussian=False):
    """
    Loads lensing convergence map for a given $\\sigma_8$ and applies Gaussian shape noise
    :param gaussian: If True, returns Gaussian map. Returns log-normal if False.
    :param noiseless: Does not take Gaussian draw if True
    :param sigma8: Value of $\\sigma_8$
    :param coadd: If True, coadds correlated and uncorrelated signals
    :param corr: If coadd is False, determines whether correlated or uncorrelated signals are returned
    :param path_to_output: relative path to the FLASK output directory
    :param nest: True for NEST pixelization, False for RING
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param density: Source galaxy density, in arcmin^2, to use for noise application
    :param density_0: Baseline galaxy density, in arcmin^2, to scale distribution by
    :param multiplier: Scale factor used to amplify noise distribution
    :param ellip_sigma: Standard deviation representing uncertainty in ellipticity measurements
    :return: A noisy Gaussian-sampled output map
    """
    if noiseless:
        return accelerated_noiseless_convergence(
            load_convergence_map_by_val(sigma8, coadd=coadd, corr=corr, path_to_output=path_to_output, nest=nest,
                                        gaussian=gaussian),
            npix=npix,
            multiplier=multiplier)
    return accelerated_gaussian_convergence_noise(
        load_convergence_map_by_val(sigma8, coadd=coadd, corr=corr, path_to_output=path_to_output, nest=nest,
                                    gaussian=gaussian),
        npix=npix,
        pixarea=pixarea, density=density, density_0=density_0, multiplier=multiplier, ellip_sigma=ellip_sigma)


def split_map(m, order=ORDER, nest=True):
    """
    Returns Numpy array of partial-sky Healpix realizations split from an input full-sky map
    :param m: Full-sky Healpix map
    :param order: ORDER giving the number of maps to split into (12*ORDER**2)
    :param nest: True if "NEST" pixelization, False if "RING"
    :return: Numpy array of split maps
    """
    return experiment_helper.hp_split(m, order, nest=nest)


def split_count_maps_by_val(sigma8, name="map-f1z1.fits.gz", path_to_output=PATH_TO_OUTPUT, field=0,
                            nest=True, npix=NPIX, pixarea=PIXEL_AREA, density=DENSITY_M, density_0=DENSITY_M,
                            multiplier=1.0, gaussian=False, rand_bias=False, mixed_bias=False, prior_low=0.8,
                            prior_high=3.0,
                            bias=BIAS, normalize=True, order=ORDER, noiseless=False):
    """
    Generates partial-sky maps with applied Poissonian shot noise for a given $\\sigma_8$
    :param mixed_bias: If True, applies separate random linear bias to each partial-sky map.
    :param gaussian: If True, returns Gaussian map. Returns log-normal if False.
    :param prior_high: Upper limit of flat prior for linear bias. Used only if rand_bias is True.
    :param prior_low: Lower limit of flat prior for linear bias. Used only if rand_bias is True.
    :param rand_bias: If True, applies random linear bias within a certain flat prior to raw map
    :param sigma8: Value of $\\sigma_8$
    :param name: name of the map
    :param path_to_output: relative path to the FLASK output directory
    :param field: field of the map (for lensing maps with multiple fields)
    :param nest: True for NEST pixellization, False for RING
    :return: Numpy array with map
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param nest: True if "NEST" pixelization, False if "RING"
    :param density: Tracer galaxy density, in arcmin^2, to use for noise application
    :param density_0: Baseline galaxy density, in arcmin^2, to scale distribution by
    :param multiplier: Scale factor used to amplify noise distribution
    :param bias: Linear galaxy-matter bias
    :param normalize: True if resulting noise should be made to reflect a linear galaxy-matter bias of 1
    :param order: ORDER giving the number of maps to split into (12*ORDER**2)
    :param noiseless: Does not take Poisson draw if True
    :return: Numpy array of split, (rescaled) Poisson-sampled maps
    """
    if mixed_bias:
        p = split_map(load_map_by_val(sigma8, name=name, path_to_output=path_to_output, field=field, nest=nest,
                                      gaussian=gaussian))
        for i in range(12 * order ** 2):
            if noiseless is True:
                p[i] = accelerated_noiseless_counts(p[i], npix=npix, pixarea=pixarea, density=density,
                                                    density_0=density_0,
                                                    multiplier=multiplier, bias=bias, rand_bias=rand_bias,
                                                    prior_low=prior_low,
                                                    prior_high=prior_high, normalize=normalize)
            else:
                p[i] = accelerated_poissonian_shot_noise(p[i], npix=npix, pixarea=pixarea, density=density,
                                                         density_0=density_0,
                                                         multiplier=multiplier, bias=bias, rand_bias=rand_bias,
                                                         prior_low=prior_low,
                                                         prior_high=prior_high, normalize=normalize)
        return p
    return split_map(count_map_by_val(sigma8, name=name, path_to_output=path_to_output, field=field, nest=nest,
                                      npix=npix, pixarea=pixarea, density=density, density_0=density_0,
                                      multiplier=multiplier, gaussian=gaussian, rand_bias=rand_bias,
                                      prior_low=prior_low, prior_high=prior_high,
                                      bias=bias, normalize=normalize, noiseless=noiseless), order=order, nest=nest)


def split_shear_maps_by_val(sigma8, coadd=True, corr=None, path_to_output=PATH_TO_OUTPUT, nest=True, npix=NPIX,
                            pixarea=PIXEL_AREA, gaussian=False,
                            density=DENSITY_KG, density_0=DENSITY_KG, multiplier=1.0,
                            ellip_sigma=ELLIP_SIGMA, noiseless=False, order=ORDER):
    """
    Generates partial-sky shear maps with applied Gaussian shape noise for a given $\\sigma_8$
    :param sigma8: Value of $\\sigma_8$
    :param gaussian: If True, returns Gaussian map. Returns log-normal if False.
    :param coadd: If True, coadds correlated and uncorrelated signals
    :param corr: If coadd is False, determines whether correlated or uncorrelated signals are returned
    :param path_to_output: relative path to the FLASK output directory
    :param nest: True for NEST pixelization, False for RING
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param density: Source galaxy density, in arcmin^2, to use for noise application
    :param density_0: Baseline galaxy density, in arcmin^2, to scale distribution by
    :param multiplier: Scale factor used to amplify noise distribution
    :param ellip_sigma: Standard deviation representing uncertainty in ellipticity measurements
    :param noiseless: Does not take Gaussian draw if True
    :param order: ORDER giving the number of maps to split into (12*ORDER**2)
    :return: Numpy array of split, (rescaled) Gaussian-sampled maps
    """
    g = shear_maps_by_val(sigma8, coadd=coadd, corr=corr, path_to_output=path_to_output, nest=nest, npix=npix,
                          pixarea=pixarea, density=density, density_0=density_0, multiplier=multiplier,
                          ellip_sigma=ellip_sigma, noiseless=noiseless, gaussian=gaussian)
    return [split_map(g[i], order=order, nest=nest) for i in range(2)]


def split_convergence_maps_by_val(sigma8, coadd=True, corr=None, path_to_output=PATH_TO_OUTPUT, nest=True, npix=NPIX,
                                  pixarea=PIXEL_AREA, gaussian=False,
                                  density=DENSITY_KG, density_0=DENSITY_KG, multiplier=1.0,
                                  ellip_sigma=ELLIP_SIGMA, noiseless=False, order=ORDER):
    """
    Generates partial-sky convergence maps with applied Gaussian shape noise for a given $\\sigma_8$
    :param sigma8: Value of $\\sigma_8$
    :param gaussian: If True, returns Gaussian map. Returns log-normal if False.
    :param coadd: If True, coadds correlated and uncorrelated signals
    :param corr: If coadd is False, determines whether correlated or uncorrelated signals are returned
    :param path_to_output: relative path to the FLASK output directory
    :param nest: True for NEST pixelization, False for RING
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param density: Source galaxy density, in arcmin^2, to use for noise application
    :param density_0: Baseline galaxy density, in arcmin^2, to scale distribution by
    :param multiplier: Scale factor used to amplify noise distribution
    :param ellip_sigma: Standard deviation representing uncertainty in ellipticity measurements
    :param noiseless: Does not take Gaussian draw if True
    :param order: ORDER giving the number of maps to split into (12*ORDER**2)
    :return: Numpy array of split, (rescaled) Gaussian-sampled maps
    """
    return split_map(
        convergence_map_by_val(sigma8, coadd=coadd, corr=corr, path_to_output=path_to_output, nest=nest, npix=npix,
                               pixarea=pixarea, density=density, density_0=density_0, multiplier=multiplier,
                               ellip_sigma=ellip_sigma, noiseless=noiseless, gaussian=gaussian), order=order, nest=nest)


def split_lensing_maps_by_val(sigma8, config="g", coadd=True, corr=None, path_to_output=PATH_TO_OUTPUT, nest=True,
                              npix=NPIX, gaussian=False,
                              pixarea=PIXEL_AREA,
                              density=DENSITY_KG, density_0=DENSITY_KG, multiplier=1.0,
                              ellip_sigma=ELLIP_SIGMA, noiseless=False, order=ORDER):
    """
    Generates a set of partial-sky lensing maps with applied Gaussian shape noise for a given $\\sigma_8$
    :param sigma8: Value of $\\sigma_8$
    :param gaussian: If True, returns Gaussian map. Returns log-normal if False.
    :param coadd: If True, coadds correlated and uncorrelated signals
    :param corr: If coadd is False, determines whether correlated or uncorrelated signals are returned
    :param path_to_output: relative path to the FLASK output directory
    :param nest: True for NEST pixelization, False for RING
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param density: Source galaxy density, in arcmin^2, to use for noise application
    :param density_0: Baseline galaxy density, in arcmin^2, to scale distribution by
    :param multiplier: Scale factor used to amplify noise distribution
    :param ellip_sigma: Standard deviation representing uncertainty in ellipticity measurements
    :param noiseless: Does not take Gaussian draw if True
    :param order: ORDER giving the number of maps to split into (12*ORDER**2)
    :param config: "k" for convergence only, "g" for shear only, "kg" for convergence and shear
    :return: Numpy array of split, (rescaled) Gaussian-sampled maps
    """
    if config == "g":
        g = split_shear_maps_by_val(sigma8, coadd=coadd, corr=corr, path_to_output=path_to_output, nest=nest, npix=npix,
                                    pixarea=pixarea, density=density, density_0=density_0, multiplier=multiplier,
                                    ellip_sigma=ellip_sigma, noiseless=noiseless, order=order, gaussian=gaussian)
        return np.stack((g[0], g[1]), axis=2)
    if config == "k":
        return split_convergence_maps_by_val(sigma8, coadd=coadd, corr=corr, path_to_output=path_to_output, nest=nest,
                                             npix=npix, gaussian=gaussian,
                                             pixarea=pixarea, density=density, density_0=density_0,
                                             multiplier=multiplier,
                                             ellip_sigma=ellip_sigma, noiseless=noiseless, order=order)
    if config == "kg":
        g = split_shear_maps_by_val(sigma8, coadd=coadd, corr=corr, path_to_output=path_to_output, nest=nest, npix=npix,
                                    pixarea=pixarea, density=density, density_0=density_0, multiplier=multiplier,
                                    ellip_sigma=ellip_sigma, noiseless=noiseless, order=order, gaussian=gaussian)
        k = split_convergence_maps_by_val(sigma8, coadd=coadd, corr=corr, path_to_output=path_to_output, nest=nest,
                                          npix=npix, gaussian=gaussian,
                                          pixarea=pixarea, density=density, density_0=density_0, multiplier=multiplier,
                                          ellip_sigma=ellip_sigma, noiseless=noiseless, order=order)
        return np.stack((g[0], g[1], k), axis=2)
    print("Unknown config in deep_dss.utils.split_lensing_maps_by_val. Please try again.")


def split_count_maps_by_vals(sigma8s, name="map-f1z1.fits.gz", path_to_output=PATH_TO_OUTPUT, field=0,
                             nest=True, npix=NPIX, pixarea=PIXEL_AREA, density=DENSITY_M, density_0=DENSITY_M,
                             multiplier=1.0, gaussian=False, rand_bias=False, mixed_bias=False, prior_low=0.8,
                             prior_high=3.0, bias=BIAS, normalize=True, noiseless=False, order=ORDER, scramble=False,
                             ground_truths=True, reshape_x=False, reshape_y=True, deepsphere_dataset=False):
    """
    Generates stacked array of partial-sky Poisson-sampled maps for a list of $\\sigma_8$ values
    :param mixed_bias: If True, applies separate random linear bias to each partial-sky map.
    :param gaussian: If True, returns Gaussian map. Returns log-normal if False.
    :param prior_high: Upper limit of flat prior for linear bias. Used only if rand_bias is True.
    :param prior_low: Lower limit of flat prior for linear bias. Used only if rand_bias is True.
    :param rand_bias: If True, applies random linear bias within a certain flat prior to raw map.
    :param deepsphere_dataset: Returns a DeepSphere LabeledDataset if true
    :param reshape_y: If True, reshapes ys to have shape (.., .., 1)
    :param reshape_x: If True, reshapes xs to have shape (.., .., 1)
    :param sigma8s: List of $\\sigma_8$ values
    :param name: name of the map
    :param path_to_output: relative path to the FLASK output directory
    :param field: field of the map (for lensing maps with multiple fields)
    :param nest: True for NEST pixellization, False for RING
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param nest: True if "NEST" pixelization, False if "RING"
    :param density: Tracer galaxy density, in arcmin^2, to use for noise application
    :param density_0: Baseline galaxy density, in arcmin^2, to scale distribution by
    :param multiplier: Scale factor used to amplify noise distribution
    :param bias: Linear galaxy-matter bias
    :param normalize: True if resulting noise should be made to reflect a linear galaxy-matter bias of 1
    :param noiseless: Does not take Poisson draw if True
    :param order: ORDER giving the number of maps to split into (12*ORDER**2)
    :param scramble: If True, randomly scrambles the maps out of order
    :param ground_truths: True if corresponding labels should be returned as well
    :return: Dictionary of DeepSphere datasets if deepsphere_dataset=True, maps and labels if ground_truths=True,
        stacked Numpy array of split, (rescaled) Poisson-sampled maps otherwise
    """
    x = np.empty((0, npix // (12 * order * order)))
    for sigma8 in sigma8s:
        m = split_count_maps_by_val(sigma8, name=name, path_to_output=path_to_output, field=field,
                                    nest=nest, npix=npix, pixarea=pixarea, density=density, density_0=density_0,
                                    multiplier=multiplier, gaussian=gaussian, rand_bias=rand_bias,
                                    mixed_bias=mixed_bias, prior_low=prior_low, prior_high=prior_high,
                                    bias=bias, normalize=normalize, noiseless=noiseless, order=order)
        x = np.vstack((x, m))
    if reshape_x:
        x = np.reshape(x, (len(sigma8s) * 12 * order * order, npix // (12 * order * order), 1))
    if ground_truths:
        y = np.zeros(len(sigma8s) * 12 * order * order)
        for i in range(len(sigma8s)):
            y[i * 12 * order * order:(i * 12 * order * order + 12 * order * order)] = sigma8s[i]
        if reshape_y:
            y = np.reshape(y, (len(sigma8s) * 12 * order * order, 1))
        if scramble:
            (x, y) = shuffle(x, y, random_state=0)
        if deepsphere_dataset:
            return LabeledDataset(x, y)
        return {"x": x, "y": y}
    if scramble:
        x = shuffle(x, random_state=0)
    return x


def lensing_channels(config):
    """
    Returns number of channels associated with a given lensing config string
    :param config: Lensing config string
    :return: int number of channels
    """
    if config == "g":
        return 2
    if config == "k":
        return 1
    if config == "kg":
        return 3
    if config == "":
        return 0
    print("Unknown config in deep_dss.utils.lensing_channels. Please try again.")


def split_lensing_maps_by_vals(sigma8s, config="g", coadd=True, corr=None, path_to_output=PATH_TO_OUTPUT, nest=True,
                               npix=NPIX, gaussian=False,
                               pixarea=PIXEL_AREA,
                               density=DENSITY_KG, density_0=DENSITY_KG, multiplier=1.0,
                               ellip_sigma=ELLIP_SIGMA, noiseless=False, order=ORDER, scramble=False,
                               ground_truths=True, reshape_x=False, reshape_y=True, deepsphere_dataset=False):
    """
    Generates stacked array of partial-sky Gaussian-sampled maps for a list of $\\sigma_8$ values
    :param gaussian: If True, returns Gaussian map. Returns log-normal if False.
    :param sigma8s: List of $\\sigma_8$ values
    :param coadd: If True, coadds correlated and uncorrelated signals
    :param corr: If coadd is False, determines whether correlated or uncorrelated signals are returned
    :param path_to_output: relative path to the FLASK output directory
    :param nest: True for NEST pixelization, False for RING
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param density: Source galaxy density, in arcmin^2, to use for noise application
    :param density_0: Baseline galaxy density, in arcmin^2, to scale distribution by
    :param multiplier: Scale factor used to amplify noise distribution
    :param ellip_sigma: Standard deviation representing uncertainty in ellipticity measurements
    :param noiseless: Does not take Gaussian draw if True
    :param order: ORDER giving the number of maps to split into (12*ORDER**2)
    :param config: "k" for convergence only, "g" for shear only, "kg" for convergence and shear
    :param scramble: If True, randomly scrambles the maps out of order
    :param ground_truths: True if corresponding labels should be returned as well
    :param reshape_x: If True, reshapes xs to have shape (.., .., 1)
    :param reshape_y: If True, reshapes ys to have shape (.., .., 1)
    :param deepsphere_dataset: Returns a DeepSphere LabeledDataset if true
    :return: Dictionary of DeepSphere datasets if deepsphere_dataset=True, maps and labels if ground_truths=True,
        stacked Numpy array of split, (rescaled) Gaussian-sampled maps otherwise
    """
    channels = lensing_channels(config)
    if channels == 1:
        x = np.empty((0, npix // (12 * order * order)))
    else:
        x = np.empty((0, npix // (12 * order * order), channels))
    for sigma8 in sigma8s:
        kg = split_lensing_maps_by_val(sigma8, coadd=coadd, corr=corr, path_to_output=path_to_output,
                                       nest=nest, npix=npix, pixarea=pixarea, density=density, density_0=density_0,
                                       multiplier=multiplier, ellip_sigma=ellip_sigma,
                                       noiseless=noiseless, order=order, config=config, gaussian=gaussian)
        x = np.vstack((x, kg))
    if channels == 1 and reshape_x:
        x = np.reshape(x, (len(sigma8s) * 12 * order * order, npix // (12 * order * order), 1))
    if ground_truths:
        y = np.zeros(len(sigma8s) * 12 * order * order)
        for i in range(len(sigma8s)):
            y[i * 12 * order * order:(i * 12 * order * order + 12 * order * order)] = sigma8s[i]
        if reshape_y:
            y = np.reshape(y, (len(sigma8s) * 12 * order * order, 1))
        if scramble:
            (x, y) = shuffle(x, y, random_state=0)
        if deepsphere_dataset:
            return LabeledDataset(x, y)
        return {"x": x, "y": y}
    if scramble:
        x = shuffle(x, random_state=0)
    return x


def split_count_and_lensing_maps_by_vals(sigma8s, config="g", name="map-f1z1.fits.gz", path_to_output=PATH_TO_OUTPUT,
                                         field=0,
                                         nest=True, npix=NPIX, pixarea=PIXEL_AREA, density_m=DENSITY_M,
                                         density_m_0=DENSITY_M, multiplier_m=1.0, gaussian=False, rand_bias=False,
                                         mixed_bias=False, prior_low=0.8, prior_high=3.0,
                                         bias=BIAS, normalize=True, noiseless_m=False, coadd=True, corr=None,
                                         density_kg=DENSITY_KG, density_kg_0=DENSITY_KG, multiplier_kg=1.0,
                                         ellip_sigma=ELLIP_SIGMA, noiseless_kg=False, order=ORDER, scramble=False,
                                         ground_truths=True, reshape_x=False, reshape_y=True, deepsphere_dataset=False):
    """
    Generates stacked array of partial-sky Poisson and Gaussian-sampled maps for a list of $\\sigma_8$ values
    :param mixed_bias: If True, applies separate random linear bias to each partial-sky map.
    :param gaussian: If True, returns Gaussian map. Returns log-normal if False.
    :param prior_high: Upper limit of flat prior for linear bias. Used only if rand_bias is True.
    :param prior_low: Lower limit of flat prior for linear bias. Used only if rand_bias is True.
    :param rand_bias: If True, applies random linear bias within a certain flat prior to raw map
    :param sigma8s: List of $\\sigma_8$ values
    :param config: "k" for convergence only, "g" for shear only, "kg" for convergence and shear, with "c" added
    to the beginning for counts
    :param name: name of the map
    :param path_to_output: relative path to the FLASK output directory
    :param field: field of the map (for lensing maps with multiple fields)
    :param nest: True for NEST pixelization, False for RING
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param density_m: Tracer galaxy density, in arcmin^2, to use for noise application
    :param density_m_0: Baseline tracer galaxy density, in arcmin^2, to scale distribution by
    :param multiplier_m: Scale factor used to amplify shot noise distribution
    :param bias: Linear galaxy-matter bias
    :param normalize: True if resulting noise should be made to reflect a linear galaxy-matter bias of 1
    :param noiseless_m: Does not take Poisson draw if True
    :param coadd: If True, coadds correlated and uncorrelated signals
    :param corr: If coadd is False, determines whether correlated or uncorrelated signals are returned
    :param density_kg: Source galaxy density, in arcmin^2, to use for noise application
    :param density_kg_0: Baseline source galaxy density, in arcmin^2, to scale distribution by
    :param multiplier_kg: Scale factor used to amplify lensing noise distributions
    :param ellip_sigma: Standard deviation representing uncertainty in ellipticity measurements
    :param noiseless_kg: Does not take Gaussian draw if True
    :param order: ORDER giving the number of maps to split into (12*ORDER**2)
    :param scramble: If True, randomly scrambles the maps out of order
    :param ground_truths: True if corresponding labels should be returned as well
    :param reshape_x: If True, reshapes xs to have shape (.., .., 1)
    :param reshape_y: If True, reshapes ys to have shape (.., .., 1)
    :param deepsphere_dataset: Returns a DeepSphere LabeledDataset if true
    :return: Dictionary of DeepSphere datasets if deepsphere_dataset=True, maps and labels if ground_truths=True,
        stacked Numpy array of split, (rescaled) Poisson and Gaussian-sampled maps otherwise
    """
    counts = 0
    if config[0] == "c":
        counts = 1
        channels = 1 + lensing_channels(config[1:])
    else:
        channels = lensing_channels(config)
    if channels == 1:
        x = np.empty((0, npix // (12 * order * order)))
    else:
        x = np.empty((0, npix // (12 * order * order), channels))
    for sigma8 in sigma8s:
        if counts == 0:
            kg = split_lensing_maps_by_val(sigma8, coadd=coadd, corr=corr, path_to_output=path_to_output,
                                           nest=nest, npix=npix, pixarea=pixarea, density=density_kg,
                                           density_0=density_kg_0,
                                           multiplier=multiplier_kg, ellip_sigma=ellip_sigma,
                                           noiseless=noiseless_kg, order=order, config=config, gaussian=gaussian)
            x = np.vstack((x, kg))
        else:
            c = split_count_maps_by_val(sigma8, name=name, path_to_output=path_to_output, field=field,
                                        nest=nest, npix=npix, pixarea=pixarea, density=density_m,
                                        density_0=density_m_0,
                                        multiplier=multiplier_m,
                                        bias=bias, normalize=normalize, noiseless=noiseless_m,
                                        order=order, gaussian=gaussian, rand_bias=rand_bias, mixed_bias=mixed_bias,
                                        prior_low=prior_low, prior_high=prior_high)
            if channels == 1:
                x = np.vstack((x, c))
            else:
                c = np.reshape(c, (12 * order * order, npix // (12 * order * order), 1))
                kg = split_lensing_maps_by_val(sigma8, coadd=coadd, corr=corr, path_to_output=path_to_output,
                                               nest=nest, npix=npix, pixarea=pixarea, density=density_kg,
                                               density_0=density_kg_0,
                                               multiplier=multiplier_kg, ellip_sigma=ellip_sigma,
                                               noiseless=noiseless_kg, order=order, config=config[1:],
                                               gaussian=gaussian)
                if channels - counts == 1:
                    kg = np.reshape(kg, (12 * order * order, npix // (12 * order * order), 1))
                x = np.vstack((x, np.concatenate((c, kg), axis=2)))
    if channels == 1 and reshape_x:
        x = np.reshape(x, (len(sigma8s) * 12 * order * order, npix // (12 * order * order), 1))
    if ground_truths:
        y = np.zeros(len(sigma8s) * 12 * order * order)
        for i in range(len(sigma8s)):
            y[i * 12 * order * order:(i * 12 * order * order + 12 * order * order)] = sigma8s[i]
        if reshape_y:
            y = np.reshape(y, (len(sigma8s) * 12 * order * order, 1))
        if scramble:
            (x, y) = shuffle(x, y, random_state=0)
        if deepsphere_dataset:
            return LabeledDataset(x, y)
        return {"x": x, "y": y}
    if scramble:
        x = shuffle(x, random_state=0)
    return x


def split_count_maps_by_dataset(dataset, name="map-f1z1.fits.gz", path_to_output=PATH_TO_OUTPUT, field=0,
                                nest=True, npix=NPIX, pixarea=PIXEL_AREA, density=DENSITY_M, density_0=DENSITY_M,
                                multiplier=1.0, gaussian=False, rand_bias=False,
                                mixed_bias=False, prior_low=0.8, prior_high=3.0,
                                bias=BIAS, normalize=True, noiseless=False, order=ORDER, scramble=False,
                                ground_truths=True, reshape_x=False, reshape_y=True, deepsphere_dataset=False):
    """
    Generates stacked array of partial-sky Poisson-sampled maps for a given data set
    :param mixed_bias: If True, applies separate random linear bias to each partial-sky map.
    :param gaussian: If True, returns Gaussian map. Returns log-normal if False.
    :param prior_high: Upper limit of flat prior for linear bias. Used only if rand_bias is True.
    :param prior_low: Lower limit of flat prior for linear bias. Used only if rand_bias is True.
    :param rand_bias: If True, applies random linear bias within a certain flat prior to raw map
    :param dataset: String name of data-set to be used
    :param name: name of the map
    :param path_to_output: relative path to the FLASK output directory
    :param field: field of the map (for lensing maps with multiple fields)
    :param nest: True for NEST pixelization, False for RING
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param nest: True if "NEST" pixelization, False if "RING"
    :param density: Tracer galaxy density, in arcmin^2, to use for noise application
    :param density_0: Baseline galaxy density, in arcmin^2, to scale distribution by
    :param multiplier: Scale factor used to amplify noise distribution
    :param bias: Linear galaxy-matter bias
    :param normalize: True if resulting noise should be made to reflect a linear galaxy-matter bias of 1
    :param noiseless: Does not take Poisson draw if True
    :param order: ORDER giving the number of maps to split into (12*ORDER**2)
    :param scramble: If True, randomly scrambles the maps out of order
    :param ground_truths: True if corresponding labels should be returned as well
    :param reshape_y: If True, reshapes ys to have shape (.., .., 1)
    :param reshape_x: If True, reshapes xs to have shape (.., .., 1)
    :param deepsphere_dataset: Returns a DeepSphere LabeledDataset if true
    :return: Stacked Numpy array of split, (rescaled) Poisson-sampled maps
    """
    return split_count_maps_by_vals(cosmologies_list(dataset), name=name, path_to_output=path_to_output, field=field,
                                    nest=nest, npix=npix, pixarea=pixarea, density=density, density_0=density_0,
                                    multiplier=multiplier,
                                    bias=bias, normalize=normalize, noiseless=noiseless, order=order,
                                    scramble=scramble,
                                    ground_truths=ground_truths, reshape_x=reshape_x, reshape_y=reshape_y,
                                    deepsphere_dataset=deepsphere_dataset, gaussian=gaussian, rand_bias=rand_bias,
                                    mixed_bias=mixed_bias, prior_low=prior_low, prior_high=prior_high)


def split_lensing_maps_by_dataset(dataset, config="g", coadd=True, corr=None, path_to_output=PATH_TO_OUTPUT, nest=True,
                                  npix=NPIX, gaussian=False,
                                  pixarea=PIXEL_AREA,
                                  density=DENSITY_KG, density_0=DENSITY_KG, multiplier=1.0,
                                  ellip_sigma=ELLIP_SIGMA, noiseless=False, order=ORDER, scramble=False,
                                  ground_truths=True, reshape_x=False, reshape_y=True, deepsphere_dataset=False):
    """
    Generates stacked array of partial-sky Gaussian-sampled maps for a given data-set
    :param gaussian: If True, returns Gaussian map. Returns log-normal if False.
    :param dataset: String name of data-set to be used
    :param coadd: If True, coadds correlated and uncorrelated signals
    :param corr: If coadd is False, determines whether correlated or uncorrelated signals are returned
    :param path_to_output: relative path to the FLASK output directory
    :param nest: True for NEST pixelization, False for RING
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param density: Source galaxy density, in arcmin^2, to use for noise application
    :param density_0: Baseline galaxy density, in arcmin^2, to scale distribution by
    :param multiplier: Scale factor used to amplify noise distribution
    :param ellip_sigma: Standard deviation representing uncertainty in ellipticity measurements
    :param noiseless: Does not take Gaussian draw if True
    :param order: ORDER giving the number of maps to split into (12*ORDER**2)
    :param config: "k" for convergence only, "g" for shear only, "kg" for convergence and shear
    :param scramble: If True, randomly scrambles the maps out of order
    :param ground_truths: True if corresponding labels should be returned as well
    :param reshape_x: If True, reshapes xs to have shape (.., .., 1)
    :param reshape_y: If True, reshapes ys to have shape (.., .., 1)
    :param deepsphere_dataset: Returns a DeepSphere LabeledDataset if true
    :return: Dictionary of DeepSphere datasets if deepsphere_dataset=True, maps and labels if ground_truths=True,
        stacked Numpy array of split, (rescaled) Gaussian-sampled maps otherwise
    """
    return split_lensing_maps_by_vals(cosmologies_list(dataset), config=config, coadd=coadd, corr=corr,
                                      path_to_output=path_to_output, nest=nest,
                                      npix=npix,
                                      pixarea=pixarea,
                                      density=density, density_0=density_0, multiplier=multiplier,
                                      ellip_sigma=ellip_sigma, noiseless=noiseless, order=order, scramble=scramble,
                                      ground_truths=ground_truths, reshape_x=reshape_x, reshape_y=reshape_y,
                                      deepsphere_dataset=deepsphere_dataset, gaussian=gaussian)


def split_count_and_lensing_maps_by_dataset(dataset, config="g", name="map-f1z1.fits.gz", path_to_output=PATH_TO_OUTPUT,
                                            field=0,
                                            nest=True, npix=NPIX, pixarea=PIXEL_AREA, density_m=DENSITY_M,
                                            density_m_0=DENSITY_M,
                                            multiplier_m=1.0, gaussian=False, rand_bias=False,
                                            mixed_bias=False, prior_low=0.8, prior_high=3.0,
                                            bias=BIAS, normalize=True, noiseless_m=False, coadd=True, corr=None,
                                            density_kg=DENSITY_KG, density_kg_0=DENSITY_KG, multiplier_kg=1.0,
                                            ellip_sigma=ELLIP_SIGMA, noiseless_kg=False, order=ORDER, scramble=False,
                                            ground_truths=True, reshape_x=False, reshape_y=True,
                                            deepsphere_dataset=False):
    """
    Generates stacked array of partial-sky Poisson and Gaussian-sampled maps for a given data-set
    :param mixed_bias: If True, applies separate random linear bias to each partial-sky map.
    :param gaussian: If True, returns Gaussian map. Returns log-normal if False.
    :param prior_high: Upper limit of flat prior for linear bias. Used only if rand_bias is True.
    :param prior_low: Lower limit of flat prior for linear bias. Used only if rand_bias is True.
    :param rand_bias: If True, applies random linear bias within a certain flat prior to raw map
    :param dataset: String name of data-set to be used
    :param config: "k" for convergence only, "g" for shear only, "kg" for convergence and shear,
    with "c" added to the beginning for counts
    :param name: name of the map
    :param path_to_output: relative path to the FLASK output directory
    :param field: field of the map (for lensing maps with multiple fields)
    :param nest: True for NEST pixelization, False for RING
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param density_m: Tracer galaxy density, in arcmin^2, to use for noise application
    :param density_m_0: Baseline tracer galaxy density, in arcmin^2, to scale distribution by
    :param multiplier_m: Scale factor used to amplify shot noise distribution
    :param bias: Linear galaxy-matter bias
    :param normalize: True if resulting noise should be made to reflect a linear galaxy-matter bias of 1
    :param noiseless_m: Does not take Poisson draw if True
    :param coadd: If True, coadds correlated and uncorrelated signals
    :param corr: If coadd is False, determines whether correlated or uncorrelated signals are returned
    :param density_kg: Source galaxy density, in arcmin^2, to use for noise application
    :param density_kg_0: Baseline source galaxy density, in arcmin^2, to scale distribution by
    :param multiplier_kg: Scale factor used to amplify lensing noise distributions
    :param ellip_sigma: Standard deviation representing uncertainty in ellipticity measurements
    :param noiseless_kg: Does not take Gaussian draw if True
    :param order: ORDER giving the number of maps to split into (12*ORDER**2)
    :param scramble: If True, randomly scrambles the maps out of order
    :param ground_truths: True if corresponding labels should be returned as well
    :param reshape_x: If True, reshapes xs to have shape (.., .., 1)
    :param reshape_y: If True, reshapes ys to have shape (.., .., 1)
    :param deepsphere_dataset: Returns a DeepSphere LabeledDataset if true
    :return: Dictionary of DeepSphere datasets if deepsphere_dataset=True, maps and labels if ground_truths=True,
        stacked Numpy array of split, (rescaled) Poisson and Gaussian-sampled maps otherwise
    """
    return split_count_and_lensing_maps_by_vals(cosmologies_list(dataset), config=config, name=name,
                                                path_to_output=path_to_output,
                                                field=field,
                                                nest=nest, npix=npix, pixarea=pixarea, density_m=density_m,
                                                density_m_0=density_m_0,
                                                multiplier_m=multiplier_m, gaussian=gaussian, rand_bias=rand_bias,
                                                mixed_bias=mixed_bias, prior_low=prior_low, prior_high=prior_high,
                                                bias=bias, normalize=normalize, noiseless_m=noiseless_m, coadd=coadd,
                                                corr=corr,
                                                density_kg=density_kg, density_kg_0=density_kg_0,
                                                multiplier_kg=multiplier_kg,
                                                ellip_sigma=ellip_sigma, noiseless_kg=noiseless_kg, order=order,
                                                scramble=scramble,
                                                ground_truths=ground_truths, reshape_x=reshape_x, reshape_y=reshape_y,
                                                deepsphere_dataset=deepsphere_dataset)


def split_count_maps_by_datasets(val=False, name="map-f1z1.fits.gz", path_to_output=PATH_TO_OUTPUT,
                                 field=0,
                                 nest=True, npix=NPIX, pixarea=PIXEL_AREA, density=DENSITY_M, density_0=DENSITY_M,
                                 multiplier=1.0,
                                 bias=BIAS, gaussian=False, rand_bias=False,
                                 mixed_bias=False, prior_low=0.8, prior_high=3.0, normalize=True, noiseless=False,
                                 order=ORDER, scramble=False,
                                 ground_truths=True, reshape_x=False, reshape_y=True, deepsphere_dataset=False):
    """
    Returns a data dictionary containing Poisson-sampled maps for each data-set
    :param mixed_bias: If True, applies separate random linear bias to each partial-sky map.
    :param gaussian: If True, returns Gaussian map. Returns log-normal if False.
    :param prior_high: Upper limit of flat prior for linear bias. Used only if rand_bias is True.
    :param prior_low: Lower limit of flat prior for linear bias. Used only if rand_bias is True.
    :param rand_bias: If True, applies random linear bias within a certain flat prior to raw map
    :param val: If True, validation set is included in dataset_names()
    :param name: name of the map
    :param path_to_output: relative path to the FLASK output directory
    :param field: field of the map (for lensing maps with multiple fields)
    :param nest: True for NEST pixelization, False for RING
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param nest: True if "NEST" pixelization, False if "RING"
    :param density: Tracer galaxy density, in arcmin^2, to use for noise application
    :param density_0: Baseline galaxy density, in arcmin^2, to scale distribution by
    :param multiplier: Scale factor used to amplify noise distribution
    :param bias: Linear galaxy-matter bias
    :param normalize: True if resulting noise should be made to reflect a linear galaxy-matter bias of 1
    :param noiseless: Does not take Poisson draw if True
    :param order: ORDER giving the number of maps to split into (12*ORDER**2)
    :param scramble: If True, randomly scrambles the maps out of order
    :param ground_truths: True if corresponding labels should be returned as well
    :param reshape_y: If True, reshapes ys to have shape (.., .., 1)
    :param reshape_x: If True, reshapes xs to have shape (.., .., 1)
    :param deepsphere_dataset: Returns a DeepSphere LabeledDataset if true
    :return: Dictionary of DeepSphere datasets if deepsphere_dataset=True, maps and labels if ground_truths=True,
        stacked Numpy array of split, (rescaled) Poisson and Gaussian-sampled maps otherwise
    """
    data = {}
    for dataset in dataset_names(val=val):
        data[dataset] = split_count_maps_by_dataset(dataset=dataset, name=name, path_to_output=path_to_output,
                                                    field=field,
                                                    nest=nest, npix=npix, pixarea=pixarea, density=density,
                                                    density_0=density_0, multiplier=multiplier, gaussian=gaussian,
                                                    rand_bias=rand_bias, mixed_bias=mixed_bias, prior_low=prior_low,
                                                    prior_high=prior_high,
                                                    bias=bias, normalize=normalize, noiseless=noiseless, order=order,
                                                    scramble=scramble,
                                                    ground_truths=ground_truths, reshape_x=reshape_x,
                                                    reshape_y=reshape_y, deepsphere_dataset=deepsphere_dataset)
    return data


def split_lensing_maps_by_datasets(val=False, config="g", coadd=True, corr=None, path_to_output=PATH_TO_OUTPUT,
                                   nest=True,
                                   npix=NPIX,
                                   pixarea=PIXEL_AREA, gaussian=False,
                                   density=DENSITY_KG, density_0=DENSITY_KG, multiplier=1.0,
                                   ellip_sigma=ELLIP_SIGMA, noiseless=False, order=ORDER, scramble=False,
                                   ground_truths=True, reshape_x=False, reshape_y=True, deepsphere_dataset=False):
    """
    Returns a data dictionary containing Gaussian-sampled maps for each data-set
    :param gaussian: If True, returns Gaussian map. Returns log-normal if False.
    :param val: If True, validation set is included in dataset_names()
    :param coadd: If True, coadds correlated and uncorrelated signals
    :param corr: If coadd is False, determines whether correlated or uncorrelated signals are returned
    :param path_to_output: relative path to the FLASK output directory
    :param nest: True for NEST pixelization, False for RING
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param density: Source galaxy density, in arcmin^2, to use for noise application
    :param density_0: Baseline galaxy density, in arcmin^2, to scale distribution by
    :param multiplier: Scale factor used to amplify noise distribution
    :param ellip_sigma: Standard deviation representing uncertainty in ellipticity measurements
    :param noiseless: Does not take Gaussian draw if True
    :param order: ORDER giving the number of maps to split into (12*ORDER**2)
    :param config: "k" for convergence only, "g" for shear only, "kg" for convergence and shear
    :param scramble: If True, randomly scrambles the maps out of order
    :param ground_truths: True if corresponding labels should be returned as well
    :param reshape_x: If True, reshapes xs to have shape (.., .., 1)
    :param reshape_y: If True, reshapes ys to have shape (.., .., 1)
    :param deepsphere_dataset: Returns a DeepSphere LabeledDataset if true
    :return: Dictionary of DeepSphere datasets if deepsphere_dataset=True, maps and labels if ground_truths=True,
        stacked Numpy array of split, (rescaled) Poisson and Gaussian-sampled maps otherwise
    """
    data = {}
    for dataset in dataset_names(val=val):
        data[dataset] = split_lensing_maps_by_dataset(dataset, config=config, coadd=coadd, corr=corr,
                                                      path_to_output=path_to_output, nest=nest,
                                                      npix=npix,
                                                      pixarea=pixarea, gaussian=gaussian,
                                                      density=density, density_0=density_0, multiplier=multiplier,
                                                      ellip_sigma=ellip_sigma, noiseless=noiseless, order=order,
                                                      scramble=scramble,
                                                      ground_truths=ground_truths, reshape_x=reshape_x,
                                                      reshape_y=reshape_y, deepsphere_dataset=deepsphere_dataset)
    return data


def split_count_and_lensing_maps_by_datasets(val=False, config="g", name="map-f1z1.fits.gz",
                                             path_to_output=PATH_TO_OUTPUT,
                                             field=0,
                                             nest=True, npix=NPIX, pixarea=PIXEL_AREA, density_m=DENSITY_M,
                                             density_m_0=DENSITY_M,
                                             multiplier_m=1.0, gaussian=False, rand_bias=False,
                                             mixed_bias=False, prior_low=0.8, prior_high=3.0,
                                             bias=BIAS, normalize=True, noiseless_m=False, coadd=True, corr=None,
                                             density_kg=DENSITY_KG, density_kg_0=DENSITY_KG, multiplier_kg=1.0,
                                             ellip_sigma=ELLIP_SIGMA, noiseless_kg=False, order=ORDER, scramble=False,
                                             ground_truths=True, reshape_x=False, reshape_y=True,
                                             deepsphere_dataset=False):
    """
    Returns a data dictionary containing Poisson Gaussian-sampled maps for each data-set
    :param mixed_bias: If True, applies separate random linear bias to each partial-sky map.
    :param gaussian: If True, returns Gaussian map. Returns log-normal if False.
    :param prior_high: Upper limit of flat prior for linear bias. Used only if rand_bias is True.
    :param prior_low: Lower limit of flat prior for linear bias. Used only if rand_bias is True.
    :param rand_bias: If True, applies random linear bias within a certain flat prior to raw map
    :param val: If True, validation set is included in dataset_names()
    :param config: "k" for convergence only, "g" for shear only, "kg" for convergence and shear,
    with "c" added to the beginning for counts
    :param name: name of the map
    :param path_to_output: relative path to the FLASK output directory
    :param field: field of the map (for lensing maps with multiple fields)
    :param nest: True for NEST pixelization, False for RING
    :param npix: Number of pixels in map
    :param pixarea: Area of each pixel, in arcmin^2
    :param density_m: Tracer galaxy density, in arcmin^2, to use for noise application
    :param density_m_0: Baseline tracer galaxy density, in arcmin^2, to scale distribution by
    :param multiplier_m: Scale factor used to amplify shot noise distribution
    :param bias: Linear galaxy-matter bias
    :param normalize: True if resulting noise should be made to reflect a linear galaxy-matter bias of 1
    :param noiseless_m: Does not take Poisson draw if True
    :param coadd: If True, coadds correlated and uncorrelated signals
    :param corr: If coadd is False, determines whether correlated or uncorrelated signals are returned
    :param density_kg: Source galaxy density, in arcmin^2, to use for noise application
    :param density_kg_0: Baseline source galaxy density, in arcmin^2, to scale distribution by
    :param multiplier_kg: Scale factor used to amplify lensing noise distributions
    :param ellip_sigma: Standard deviation representing uncertainty in ellipticity measurements
    :param noiseless_kg: Does not take Gaussian draw if True
    :param order: ORDER giving the number of maps to split into (12*ORDER**2)
    :param scramble: If True, randomly scrambles the maps out of order
    :param ground_truths: True if corresponding labels should be returned as well
    :param reshape_x: If True, reshapes xs to have shape (.., .., 1)
    :param reshape_y: If True, reshapes ys to have shape (.., .., 1)
    :param deepsphere_dataset: Returns a DeepSphere LabeledDataset if true
    :return: Dictionary of DeepSphere datasets if deepsphere_dataset=True, maps and labels if ground_truths=True,
        stacked Numpy array of split, (rescaled) Poisson and Gaussian-sampled maps otherwise
    """
    data = {}
    for dataset in dataset_names(val=val):
        data[dataset] = split_count_and_lensing_maps_by_vals(dataset, config=config, name=name,
                                                             path_to_output=path_to_output,
                                                             field=field,
                                                             nest=nest, npix=npix, pixarea=pixarea, density_m=density_m,
                                                             density_m_0=density_m_0,
                                                             multiplier_m=multiplier_m, gaussian=gaussian,
                                                             rand_bias=rand_bias, mixed_bias=mixed_bias,
                                                             prior_low=prior_low, prior_high=prior_high,
                                                             bias=bias, normalize=normalize, noiseless_m=noiseless_m,
                                                             coadd=coadd,
                                                             corr=corr,
                                                             density_kg=density_kg, density_kg_0=density_kg_0,
                                                             multiplier_kg=multiplier_kg,
                                                             ellip_sigma=ellip_sigma, noiseless_kg=noiseless_kg,
                                                             order=order,
                                                             scramble=scramble,
                                                             ground_truths=ground_truths, reshape_x=reshape_x,
                                                             reshape_y=reshape_y,
                                                             deepsphere_dataset=deepsphere_dataset)
    return data


def list_tracer_noise_scales(handpicked=False, num=6, noiseless=True):
    """
    Generate a list of noise levels (tracer galaxy densities in arcmin^2) at which to evaluate model predictions.
    :param noiseless: If True, includes noiseless case.
    :param num: Number of noise levels (exluding noiseless case) to generate
    :param handpicked: If True, return handpicked list of noise-levels. Use geomspace vals if false
    :return: A list of noise levels (-1 for noiseless)
    """
    if handpicked:
        if noiseless:
            return np.array([0.04377, 0.12, 0.3, 4, 50, -1])
        return np.array([0.04377, 0.12, 1, 10, 100, 1000])
    if noiseless:
        return np.append(np.geomspace(0.04377, 100, num=num), -1)
    return np.geomspace(0.04377, 1000, num=num)
